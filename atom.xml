<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>火柴的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chen-hao.com.cn/"/>
  <updated>2016-11-22T01:33:42.205Z</updated>
  <id>http://chen-hao.com.cn/</id>
  
  <author>
    <name>CH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML状态消息</title>
    <link href="http://chen-hao.com.cn/HTML%E7%8A%B6%E6%80%81%E6%B6%88%E6%81%AF.html"/>
    <id>http://chen-hao.com.cn/HTML状态消息.html</id>
    <published>2016-11-22T01:08:26.000Z</published>
    <updated>2016-11-22T01:33:42.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当浏览器从 web 服务器请求服务时，可能会发生错误。返回下面的一系列状态消息，从状态码的类型我们可以定位故障，从而解决线上环境的各种问题。<br><a id="more"></a></p>
</blockquote>
<h3>1xx: 信息</h3>

<table>
<thead>
<tr>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100 Continue</td>
<td>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求</td>
</tr>
<tr>
<td>101 Switching Protocols</td>
<td>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议</td>
</tr>
</tbody>
</table>
<h3>2xx: 成功</h3>

<table>
<thead>
<tr>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 OK</td>
<td>请求成功（其后是对GET和POST请求的应答文档）</td>
</tr>
<tr>
<td>201 Created</td>
<td>请求被创建完成，同时新的资源被创建</td>
</tr>
<tr>
<td>202 Accepted</td>
<td>供处理的请求已被接受，但是处理未完成</td>
</tr>
<tr>
<td>203 Non-authoritative Information</td>
<td>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</td>
</tr>
<tr>
<td>204 No Content</td>
<td>没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的</td>
</tr>
<tr>
<td>205 Reset Content</td>
<td>没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</td>
</tr>
<tr>
<td>206 Partial Content</td>
<td>客户发送了一个带有Range头的GET请求，服务器完成了它</td>
</tr>
</tbody>
</table>
<h3>3xx: 重定向</h3>

<table>
<thead>
<tr>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>300 Multiple Choices</td>
<td>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址</td>
</tr>
<tr>
<td>301 Moved Permanently</td>
<td>所请求的页面已经转移至新的url</td>
</tr>
<tr>
<td>302 Found</td>
<td>所请求的页面已经临时转移至新的url</td>
</tr>
<tr>
<td>303 See Other</td>
<td>所请求的页面可在别的url下被找到</td>
</tr>
<tr>
<td>304 Not Modified</td>
<td>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用</td>
</tr>
<tr>
<td>305 Use Proxy</td>
<td>客户请求的文档应该通过Location头所指明的代理服务器提取</td>
</tr>
<tr>
<td>306 Unused</td>
<td>此代码被用于前一版本。目前已不再使用，但是代码依然被保留</td>
</tr>
<tr>
<td>307 Temporary Redirect</td>
<td>被请求的页面已经临时移至新的url</td>
</tr>
</tbody>
</table>
<h3>4xx: 客户端错误</h3>

<table>
<thead>
<tr>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>400 Bad Request</td>
<td>服务器未能理解请求</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>被请求的页面需要用户名和密码</td>
</tr>
<tr>
<td>402 Payment Required    此代码尚无法使用</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>对被请求页面的访问被禁止</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>服务器无法找到被请求的页面</td>
</tr>
<tr>
<td>405 Method Not Allowed</td>
<td>请求中指定的方法不被允许</td>
</tr>
<tr>
<td>406 Not Acceptable</td>
<td>服务器生成的响应无法被客户端所接受</td>
</tr>
<tr>
<td>407 Proxy Authentication Required</td>
<td>用户必须首先使用代理服务器进行验证，这样请求才会被处理</td>
</tr>
<tr>
<td>408 Request Timeout</td>
<td>请求超出了服务器的等待时间</td>
</tr>
<tr>
<td>409 Conflict</td>
<td>由于冲突，请求无法被完成</td>
</tr>
<tr>
<td>410 Gone</td>
<td>被请求的页面不可用</td>
</tr>
<tr>
<td>411 Length Required “Content-Length”</td>
<td>未被定义。如果无此内容，服务器不会接受请求</td>
</tr>
<tr>
<td>412 Precondition Failed</td>
<td>请求中的前提条件被服务器评估为失败</td>
</tr>
<tr>
<td>413 Request Entity Too Large</td>
<td>由于所请求的实体的太大，服务器不会接受请求</td>
</tr>
<tr>
<td>414 Request-url Too Long</td>
<td>由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况</td>
</tr>
<tr>
<td>415 Unsupported Media Type</td>
<td>由于媒介类型不被支持，服务器不会接受请求</td>
</tr>
<tr>
<td>416</td>
<td>服务器不能满足客户在请求中指定的Range头</td>
</tr>
</tbody>
</table>
<h3>5xx: 服务器错误</h3>

<table>
<thead>
<tr>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>500 Internal Server Error</td>
<td>请求未完成。服务器遇到不可预知的情况</td>
</tr>
<tr>
<td>501 Not Implemented</td>
<td>请求未完成。服务器不支持所请求的功能</td>
</tr>
<tr>
<td>502 Bad Gateway</td>
<td>请求未完成。服务器从上游服务器收到一个无效的响应</td>
</tr>
<tr>
<td>503 Service Unavailable</td>
<td>请求未完成。服务器临时过载或当机</td>
</tr>
<tr>
<td>504 Gateway Timeout</td>
<td>网关超时</td>
</tr>
<tr>
<td>505 HTTP Version Not Supported</td>
<td>服务器不支持请求中指明的HTTP协议版本</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当浏览器从 web 服务器请求服务时，可能会发生错误。返回下面的一系列状态消息，从状态码的类型我们可以定位故障，从而解决线上环境的各种问题。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="http://chen-hao.com.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="http" scheme="http://chen-hao.com.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Linux杀毒软件安装及使用</title>
    <link href="http://chen-hao.com.cn/Linux%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8.html"/>
    <id>http://chen-hao.com.cn/Linux杀毒软件安装及使用.html</id>
    <published>2016-11-21T02:07:21.000Z</published>
    <updated>2016-11-21T05:05:41.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ClamAV 是Linux平台最受欢迎的杀毒软件，ClamAV 属于免费开源产品，支持多种平台。ClamAV是基于病毒扫描的命令行工具，但同时也有支持图形界面的ClamTK工具。ClamAV 主要用于邮件服务器扫描邮件。它有多种接口从邮件服务器扫描邮件。ClamAV 有自动的数据库更新器，还可以从共享库中运行。命令行的界面让 ClamAV运行流畅。<br> <a id="more"></a></p>
</blockquote>
<p></p><h3>YUM源安装</h3><br>这里直接配置好阿里云的epel源即可yum一键安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install clamav</div></pre></td></tr></table></figure><p></p>
<p></p><h3>编译安装</h3><p></p>
<p></p><h4>获取软件包</h4><br>推荐上官网下载软件包，官网 <a href="http://www.clamav.net" target="_blank" rel="external">http://www.clamav.net</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://www.clamav.net/downloads/production/clamav-0.99.2.tar.gz</div></pre></td></tr></table></figure><p></p>
<p></p><h4>准备编译环境环境</h4><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装依赖包</span></div><div class="line">yum -y insatll gcc openssl openssl-devel</div><div class="line"><span class="comment"># 创建clamav用户和组</span></div><div class="line">groupadd clamav</div><div class="line">useradd -g clamav <span class="_">-s</span> /sbin/nologin clamav</div></pre></td></tr></table></figure><p></p>
<p></p><h4>编译安装clamav</h4><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -zxf clamav-0.99.2.tar.gz</div><div class="line"><span class="built_in">cd</span> clamav-0.99.2</div><div class="line">./configure --sysconfdir=/etc</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p></p>
<p></p><h4>程序说明</h4><br>编译安装完成后，默认程序安装路径为/usr/local/bin<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/</div><div class="line">ls</div><div class="line">clamav-config  clambc  clamconf  clamdscan  clamscan  freshclam  sigtool</div></pre></td></tr></table></figure><p></p>
<table>
<thead>
<tr>
<th>程序名称</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>clamscan</td>
<td>扫描程序，最主要的一个程序</td>
</tr>
<tr>
<td>clamd</td>
<td>daemon程序，配合clamscan，因为是预载，可以更快的扫描</td>
</tr>
<tr>
<td>clamdscan</td>
<td>必须配合clamd使用</td>
</tr>
<tr>
<td>clamuko</td>
<td>是配置及时扫描的中介程序，需配合dazuko</td>
</tr>
<tr>
<td>freshclam</td>
<td>病毒码更新程序，首次安装需运行此程序更新病毒库</td>
</tr>
<tr>
<td>sigtool</td>
<td>没有被clamav扫描到的病毒，可以用此程序新增</td>
</tr>
</tbody>
</table>
<p></p><h3>使用clamav杀毒</h3><p></p>
<p></p><h4>修改配置文件</h4><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cp /etc/clamd.conf.sample /etc/clamd.conf</div><div class="line">vim /etc/clamd.conf</div><div class="line">在Example 前面加<span class="comment">#</span></div><div class="line">cp /etc/freshclam.conf.sample /etc/freshclam.conf</div><div class="line">vim /etc/freshclam.conf</div><div class="line">在Example 前面加<span class="comment">#</span></div><div class="line">在 DatabaseMirror database.clamav.net 行下面增加几个地址</div><div class="line">DatabaseMirror clamav.inet6.fr</div><div class="line">DatabaseMirror clamav.netopia.pt</div><div class="line">DatabaseMirror clamav.sonic.net</div></pre></td></tr></table></figure><p></p>
<p></p><h4>更新病毒库</h4><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新建所需要目录</span></div><div class="line">mkdir /usr/<span class="built_in">local</span>/share/clamav</div><div class="line"><span class="comment"># 修改属主属组</span></div><div class="line">chown clamav.clamav -R /usr/<span class="built_in">local</span>/share/clamav/</div><div class="line"><span class="comment"># 更新病毒库</span></div><div class="line">/usr/<span class="built_in">local</span>/bin/freshclam</div></pre></td></tr></table></figure><p></p>
<p></p><h4>clamav命令详解</h4><p></p>
<p></p><h5>命令参数</h5><p></p>
<ul>
<li>-l [路径] [文件名] 增加扫描报告</li>
<li>–quiet 安静方式，不发出任何消息，只有出现病毒才会提示</li>
<li>–move [路径] 移动病毒文件至…</li>
<li>–remove [路径] 删除病毒文件</li>
<li>–unzip(unrar) 解压压缩文件扫描</li>
</ul>
<p></p><h5>命令常用示例</h5><p></p>
<ol>
<li><p>扫描指定的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clamscan file</div></pre></td></tr></table></figure>
</li>
<li><p>扫描/home目录中所有文件 (包括子目录)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clamscan -r /home</div></pre></td></tr></table></figure>
</li>
<li><p>将扫描结果存放到log中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clamscan -r /home/<span class="built_in">test</span> <span class="_">-l</span> /tmp/clamav.log</div></pre></td></tr></table></figure>
</li>
<li><p>扫描到有问题的文件，直接删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clamscan -r --remove /home/<span class="built_in">test</span></div><div class="line"><span class="comment"># 这一步要小心，最好不要这样操作，如果删除了系统文件就麻烦了。可能导致系统崩溃</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p></p><h4>扫描返回值</h4><p></p>
<ul>
<li>0 : 无病毒 </li>
<li>1 : 发现病毒 </li>
<li>40 : 已经通过的未知选项 </li>
<li>50 : 数据库初始化错误 </li>
<li>52 : 不支持的文件格式 </li>
<li>53 : 无法打开目录 </li>
<li>54 : 不能打开文件(ofm) </li>
<li>55 : 读文件错误(ofm) </li>
<li>56 : Can’t stat input file / directory. </li>
<li>57 : Can’t get absolute path name of current working directory </li>
<li>58 : I/O 错误, 请检查文件系统 </li>
<li>59 : 无法在/etc/passwd获得当前用户的信息 </li>
<li>60 : 无法在/etc/passwd获得’clamav’（默认名）用户的信息 </li>
<li>61 : Can’t fork. </li>
<li>63 : 不能创建临时文件/目录(检查权限). |</li>
<li>64 : 无法对临时目录进行写操作 (请指定另一个目录). </li>
<li>70 : 无法分配或释放内存 (calloc). </li>
<li>71 : 无法分配内存 (malloc). </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ClamAV 是Linux平台最受欢迎的杀毒软件，ClamAV 属于免费开源产品，支持多种平台。ClamAV是基于病毒扫描的命令行工具，但同时也有支持图形界面的ClamTK工具。ClamAV 主要用于邮件服务器扫描邮件。它有多种接口从邮件服务器扫描邮件。ClamAV 有自动的数据库更新器，还可以从共享库中运行。命令行的界面让 ClamAV运行流畅。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://chen-hao.com.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ClamAV" scheme="http://chen-hao.com.cn/tags/ClamAV/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令小技巧</title>
    <link href="http://chen-hao.com.cn/Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%8A%80%E5%B7%A7.html"/>
    <id>http://chen-hao.com.cn/Linux命令小技巧.html</id>
    <published>2016-11-14T08:00:59.000Z</published>
    <updated>2016-11-15T04:05:57.505Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文不对基本的命令作过多的描述，让你了解不一样Linux命令小技巧，原来Linux还可以这么玩！<br> <a id="more"></a></p>
</blockquote>
<p></p><h3>获取磁盘空间最大的几个文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -hsx * | sort -rh | head -8</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释：</p>
<ul>
<li>du – 估计文件的空间使用情况</li>
<li>-hsx – （-h）更易读的格式，（-s）汇总输出，（-x）跳过其他文件系统的文件</li>
<li>sort – 对文本文件按行排序</li>
<li>-rf – （-r）将比较的结果逆序输出，（-f）忽略大小写</li>
<li>head – 输出文件的头几行</li>
</ul>
<p></p><h3>显示剩余内存</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">free -m | grep cache | awk <span class="string">'/[0-9]/&#123; print $4" MB" &#125;'</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>测试磁盘写入速度</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/zero of=/tmp/output.img bs=8k count=256k conv=fdatasync</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释：</p>
<ul>
<li>dd – 转换和复制文件</li>
<li>if=/dev/zero – 指定输入文件，默认为stdin（标准输入）</li>
<li>of=/tmp/output.img – 指定输出文件，默认为stdout（标准输出）</li>
<li>bs – 一次读和写的块大小，最大可以以MB为单位</li>
<li>count – 复制次数</li>
<li>conv – 使用逗号分隔的策略来转换文件（LCTT 译注：比如将大写字母转换成小写，echo AA | dd conv=lcase）</li>
</ul>
<p></p><h3>测试磁盘读取速度</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdparm -Tt /dev/vda</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释：</p>
<ul>
<li>hdparm - 读取和设置IDE或SCSI硬盘参数</li>
<li>-T - 评估硬盘快速的读取效率</li>
<li>-t - 评估硬盘的读取效率</li>
</ul>
<p></p><h3>在history中加时间和命令执行者</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div><div class="line"><span class="built_in">export</span> HISTTIMEFORMAT=<span class="string">"%d/%m/%y %T `whoami`"</span></div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释：</p>
<ul>
<li>history – 查看运行过的命令</li>
<li>HISTIMEFORMAT – 设置时间格式的环境变量<br>-%d – 天</li>
<li>%m – 月</li>
<li>%y – 年</li>
<li>%T – 时间戳</li>
<li>whoami - 当前执行命令的用户</li>
</ul>
<p></p><h3>实时监控当前命令执行的结果</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">watch -n 2 <span class="string">'cat /proc/mdstat'</span></div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释:</p>
<ul>
<li>watch - 用于周期性执行命令</li>
<li>-n - 指定间隔的时长</li>
</ul>
<p></p><h3>防止系统关键文件被篡改</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chattr +i note.txt</div><div class="line">lsattr note.txt</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释:</p>
<ul>
<li>chattr - 改变文件属性</li>
<li>lsattr - 查看文件属性</li>
<li>a - 让文件或目录仅供附加用途</li>
<li>b - 不更新文件或目录的最后存取时间</li>
<li>c - 将文件或目录压缩后存放</li>
<li>d - 将文件或目录排除在倾倒操作之外</li>
<li>i - 不得任意更动文件或目录</li>
<li>s - 保密性删除文件或目录</li>
<li>S - 即时更新文件或目录</li>
<li>u - 预防以外删除</li>
</ul>
<p></p><h3>用 Wget 的递归方式下载整个网站</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget --random-wait -r -p <span class="_">-e</span> robots=off -U Mozilla www.example.com</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释:</p>
<ul>
<li>–random-wait 等待 0.5 到 1.5 秒的时间来进行下一次请求 </li>
<li>-r 开启递归检索 </li>
<li>-e robots=off 忽略 robots.txt </li>
<li>-U Mozilla 设置 User-Agent 头为 Mozilla</li>
<li>–limit-rate=20K 限制下载速度为 20K </li>
<li>-o logfile.txt 记录下载日志 </li>
<li>-l 0 删除深度（默认为5） </li>
<li>–wait=1h 每下载一个文件后等待1小时</li>
</ul>
<p></p><h3>产生随机的十六进制数</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl rand -hex -n</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释:</p>
<ul>
<li>-n - 生成随机字符数量</li>
</ul>
<p></p><h3>检查远程端口是否对本机开放</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> &gt; /dev/tcp/8.8.8.8/53 &amp;&amp; <span class="built_in">echo</span> <span class="string">"open"</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>快速备份一个文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp some_file_name&#123;,.bkp&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>修改文件的时间戳或创建空文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch <span class="_">-a</span> -t 201601011111 test.sh</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释:</p>
<ul>
<li>-t - STAMP:指明时间 [[CC]YY]MMDDhhmm[.ss]</li>
<li>-a - 仅修改atime</li>
<li>-m - 仅修改mtime</li>
<li>-c - 不创建文件</li>
</ul>
<p></p><h3>显示文件或系统状态</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stat</span> text.txt</div></pre></td></tr></table></figure><p></p>
<p>命令和选项的解释:</p>
<ul>
<li>access time - atime,文件最近一次被访问的时间</li>
<li>modify time - mtime,文件最近一次被修改的时间（数据）</li>
<li>change time - ctime,文件最近一次改动的时间（元数据） </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文不对基本的命令作过多的描述，让你了解不一样Linux命令小技巧，原来Linux还可以这么玩！&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="http://chen-hao.com.cn/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="文件系统" scheme="http://chen-hao.com.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github访问出现页面空白问题</title>
    <link href="http://chen-hao.com.cn/hexo-github%E8%AE%BF%E9%97%AE%E5%87%BA%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%A9%BA%E7%99%BD%E9%97%AE%E9%A2%98.html"/>
    <id>http://chen-hao.com.cn/hexo-github访问出现页面空白问题.html</id>
    <published>2016-11-09T01:13:53.000Z</published>
    <updated>2016-11-09T01:32:44.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>故障重现：<br>本地预览没问题，但是deploy到github之后，主页，只显示个空白背景。<br><a id="more"></a></p>
</blockquote>
<p></p><h3>故障原因</h3><br>有人说是由于github更新，导致source/vendors目录上传不上去导致的。<p></p>
<p></p><h3>解决方案</h3><p></p>
<ol>
<li>首先修改\themes\next\source为\themes\next\lib</li>
<li>修改next主题的_config.yml， 将 _internal: vendors修改为_internal:lib</li>
<li>修改next底下所有引用source/vendors路径为source/lib</li>
<li>执行hexo clean | hexo g</li>
<li>试试hexo d上传看看稍等片刻看看页面有无内容</li>
</ol>
<p>如果以上无法解决，估计我也帮不了你，推荐几个链接，自行寻找答案。<br><a href="https://github.com/hexojs/hexo/issues/2238" target="_blank" rel="external">https://github.com/hexojs/hexo/issues/2238</a><br><a href="https://github.com/iissnan/hexo-theme-next/issues/1219" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next/issues/1219</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;故障重现：&lt;br&gt;本地预览没问题，但是deploy到github之后，主页，只显示个空白背景。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://chen-hao.com.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="github" scheme="http://chen-hao.com.cn/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>隐藏Linux系统常见软件版本号</title>
    <link href="http://chen-hao.com.cn/%E9%9A%90%E8%97%8FLinux%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7.html"/>
    <id>http://chen-hao.com.cn/隐藏Linux系统常见软件版本号.html</id>
    <published>2016-11-08T05:43:19.000Z</published>
    <updated>2016-11-09T02:28:12.606Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文主要介绍了在Linux系统的服务器上隐藏各种常用软件版本号的方法,有助于预防攻击者针对详细版本的漏洞而发起的攻击,需要的朋友可以参考下<br><a id="more"></a></p>
</blockquote>
<p></p><h3>隐藏Linux版本信息</h3><br>在登录Linux主机本地前，会显示系统的版本和内核。为了安全我们应该隐藏它<br>清空命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;/etc/issue  或 cat /dev/null &gt;etc/issue</div></pre></td></tr></table></figure><p></p>
<p>也可以编辑/etc/motd文件，来隐藏真正的版本信息。<br>/etc/motd即messageoftoday（布告栏信息）。<br>每次用户登录时，/etc/motd文件的内容会显示在用户的终端。</p>
<p></p><h3>隐藏apache版本信息</h3><br>隐藏Apache版本号的方法是修改Apache的配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/httpd/conf/httpd.conf</div><div class="line">ServerTokens ProductOnly</div><div class="line">ServerSignature Off</div></pre></td></tr></table></figure><p></p>
<p></p><h3>隐藏tomcat版本信息</h3><p></p>
<ol>
<li>找到catalina.jar 文件，一般在tomcat的安装目录lib下</li>
<li>把这个文件解压了<br>jar xf catalina.jar 如果这样解压，提示权限不够，你可以下载到本地，用winrar解压也可以的<br>又或者你可以不管它，不解压，我们来直接建我们想要的文件，也就是直接进入第3步</li>
<li>到$CATALINA_HOME/lib目录 创建org/apache/catalina/util目录<br>mkdir -p org/apache/catalina/util</li>
<li><p>创建ServerInfo.properties文件，如果你刚刚把catalina.jar解压了，可以直接在org\apache\catalina\util目录下，把它复制过来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$CATALINA_HOME</span>/lib/org/apache/catalina/util</div><div class="line">vi ServerInfo.properties <span class="comment">#编辑下面文字</span></div><div class="line">server.info=Apache Tomcat Version X0000 <span class="comment">#这里的文字，你随便定义</span></div></pre></td></tr></table></figure>
</li>
<li><p>重启tomcat服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/tomcat/bin/catalina.sh stop</div><div class="line">/usr/<span class="built_in">local</span>/tomcat/bin/catalina.sh start</div></pre></td></tr></table></figure>
</li>
</ol>
<p></p><h3>隐藏nginx版本信息</h3><br>Nginx的版本号主要在两个地方会有，一个是HTTP header，有个Server:nginx/1.x.x类似会暴露Web服务器所用软件名称以及版本号，这个也是大多数Web服务器最容易暴露版本号的地方，第二个地方是Nginx出错页面，比如404页面没有找到等，这是如果用户没有指定页面的话，那么Nginx自己的页面会有版本戳记。<p></p>
<p>不过幸运的是对于这两个地方的版本号隐藏，Nginx都提供了简单的办法一步到位，参考server_tokens。通过在配置文件的http节配置server_tokens off来达到我们目的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim nginx.conf</div><div class="line">  http &#123;</div><div class="line">    <span class="comment"># ...省略一些配置</span></div><div class="line">    server_tokens off;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p></p><h3>隐藏PHP的版本信息</h3><br>PHP容易暴露的版本号在什么地方呢？其实也是在HTTP头，以类似X-Powered-By: PHP/5.2.11这种形式存在，大家可能会想到会不会是Nginx问题，而去到Nginx里面找相关配置，呵呵，其实这个是在PHP的配置文件php.ini里改动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/php.ini</div><div class="line">expose_php = Off</div></pre></td></tr></table></figure><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要介绍了在Linux系统的服务器上隐藏各种常用软件版本号的方法,有助于预防攻击者针对详细版本的漏洞而发起的攻击,需要的朋友可以参考下&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://chen-hao.com.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="文件系统" scheme="http://chen-hao.com.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据库入门</title>
    <link href="http://chen-hao.com.cn/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8.html"/>
    <id>http://chen-hao.com.cn/Redis数据库入门.html</id>
    <published>2016-11-08T04:56:25.000Z</published>
    <updated>2016-11-08T05:33:08.579Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。redis的官网地址，非常好记，是redis.io。（特意查了一下，域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地）目前，Vmware在资助着redis项目的开发和维护。<br> <a id="more"></a></p>
</blockquote>
<p></p><h3>安装redis</h3><br>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ find . -type f -executable</div><div class="line">./redis-benchmark //用于进行redis性能测试的工具</div><div class="line">./redis-check-dump //用于修复出问题的dump.rdb文件</div><div class="line">./redis-cli //redis的客户端</div><div class="line">./redis-server //redis的服务端</div><div class="line">./redis-check-aof //用于修复出问题的AOF文件</div><div class="line">./redis-sentinel //用于集群管理</div></pre></td></tr></table></figure><p></p>
<p></p><h3>启动redis</h3><br>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-server ../redis.conf</div></pre></td></tr></table></figure><p></p>
<p>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。有关作者为什么选择6379作为默认端口，还有一段有趣的典故，英语好的同学可以看看作者这篇博文中的解释。</p>
<p></p><h3>redis客户端</h3><br>我们直接看一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//这样来启动redis客户端了</div><div class="line">$ ./redis-cli</div><div class="line">//用<span class="built_in">set</span>指令来设置key、value</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">"roc"</span> </div><div class="line">OK</div><div class="line">//来获取name的值</div><div class="line">127.0.0.1:6379&gt; get name </div><div class="line"><span class="string">"roc"</span></div><div class="line">//通过客户端来关闭redis服务端</div><div class="line">127.0.0.1:6379&gt; shutdown </div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>redis数据结构 – 简介</h3><br>redis是一种高级的key:value存储系统，其中value支持五种数据类型：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.字符串（strings）</div><div class="line">2.字符串列表（lists）</div><div class="line">3.字符串集合（sets）</div><div class="line">4.有序字符串集合（sorted sets）</div><div class="line">5.哈希（hashes）</div></pre></td></tr></table></figure><p></p>
<p>而关于key，有几个点要提醒大家：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；</div><div class="line">2.key也不要太短，太短的话，key的可读性会降低；</div><div class="line">3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</div></pre></td></tr></table></figure></p>
<p></p><h4>redis数据结构 – strings</h4><br>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。<p></p>
<p>我们来看一个最简单的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mystr <span class="string">"hello world!"</span> //设置字符串类型</div><div class="line">get mystr //读取字符串类型</div></pre></td></tr></table></figure></p>
<p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。<br>另外，我们还可以通过字符串类型进行数值操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> mynum <span class="string">"2"</span></div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; get mynum</div><div class="line"><span class="string">"2"</span></div><div class="line">127.0.0.1:6379&gt; incr mynum</div><div class="line">(<span class="built_in">integer</span>) 3</div><div class="line">127.0.0.1:6379&gt; get mynum</div><div class="line"><span class="string">"3"</span></div></pre></td></tr></table></figure></p>
<p>看，在遇到数值操作时，redis会将字符串类型转换成数值。</p>
<p>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。</p>
<p></p><h4>redis数据结构 – lists</h4><br>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。<br>首先要明确一点，redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。<br>虽然lists有这样的优势，但同样有其弊端，那就是，链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。<br>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。我们来看几个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//新建一个list叫做mylist，并在列表头部插入元素<span class="string">"1"</span></div><div class="line">127.0.0.1:6379&gt; lpush mylist <span class="string">"1"</span> </div><div class="line">//返回当前mylist中的元素个数</div><div class="line">(<span class="built_in">integer</span>) 1 </div><div class="line">//在mylist右侧插入元素<span class="string">"2"</span></div><div class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">"2"</span> </div><div class="line">(<span class="built_in">integer</span>) 2</div><div class="line">//在mylist左侧插入元素<span class="string">"0"</span></div><div class="line">127.0.0.1:6379&gt; lpush mylist <span class="string">"0"</span> </div><div class="line">(<span class="built_in">integer</span>) 3</div><div class="line">//列出mylist中从编号0到编号1的元素</div><div class="line">127.0.0.1:6379&gt; lrange mylist 0 1 </div><div class="line">1) <span class="string">"0"</span></div><div class="line">2) <span class="string">"1"</span></div><div class="line">//列出mylist中从编号0到倒数第一个元素</div><div class="line">127.0.0.1:6379&gt; lrange mylist 0 -1 </div><div class="line">1) <span class="string">"0"</span></div><div class="line">2) <span class="string">"1"</span></div><div class="line">3) <span class="string">"2"</span></div></pre></td></tr></table></figure><p></p>
<p>lists的应用相当广泛，随便举几个例子：<br>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p>
<p></p><h4>redis数据结构 – 集合</h4><br>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。<br>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//向集合myset中加入一个新元素<span class="string">"one"</span></div><div class="line">127.0.0.1:6379&gt; sadd myset <span class="string">"one"</span> </div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; sadd myset <span class="string">"two"</span></div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">//列出集合myset中的所有元素</div><div class="line">127.0.0.1:6379&gt; smembers myset </div><div class="line">1) <span class="string">"one"</span></div><div class="line">2) <span class="string">"two"</span></div><div class="line">//判断元素1是否在集合myset中，返回1表示存在</div><div class="line">127.0.0.1:6379&gt; sismember myset <span class="string">"one"</span> </div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">//判断元素3是否在集合myset中，返回0表示不存在</div><div class="line">127.0.0.1:6379&gt; sismember myset <span class="string">"three"</span> </div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">//新建一个新的集合yourset</div><div class="line">127.0.0.1:6379&gt; sadd yourset <span class="string">"1"</span> </div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; sadd yourset <span class="string">"2"</span></div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; smembers yourset</div><div class="line">1) <span class="string">"1"</span></div><div class="line">2) <span class="string">"2"</span></div><div class="line">//对两个集合求并集</div><div class="line">127.0.0.1:6379&gt; sunion myset yourset </div><div class="line">1) <span class="string">"1"</span></div><div class="line">2) <span class="string">"one"</span></div><div class="line">3) <span class="string">"2"</span></div><div class="line">4) <span class="string">"two"</span></div></pre></td></tr></table></figure><p></p>
<p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p>
<p></p><h4>redis数据结构 – 有序集合</h4><br>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。<br>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等<p></p>
<p>老规矩，我们来看几个生动的例子：<br>//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; zadd myzset 1 baidu.com </div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">//向myzset中新增一个元素360.com，赋予它的序号是3</div><div class="line">127.0.0.1:6379&gt; zadd myzset 3 360.com </div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">//向myzset中新增一个元素google.com，赋予它的序号是2</div><div class="line">127.0.0.1:6379&gt; zadd myzset 2 google.com </div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。</div><div class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 with scores </div><div class="line">1) <span class="string">"baidu.com"</span></div><div class="line">2) <span class="string">"1"</span></div><div class="line">3) <span class="string">"google.com"</span></div><div class="line">4) <span class="string">"2"</span></div><div class="line">5) <span class="string">"360.com"</span></div><div class="line">6) <span class="string">"3"</span></div><div class="line">//只列出myzset的元素</div><div class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 </div><div class="line">1) <span class="string">"baidu.com"</span></div><div class="line">2) <span class="string">"google.com"</span></div><div class="line">3) <span class="string">"360.com"</span></div></pre></td></tr></table></figure></p>
<p></p><h4>redis数据结构 – 哈希</h4><br>最后要给大家介绍的是hashes，即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。<br>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。<p></p>
<p>我们来看一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//建立哈希，并赋值</div><div class="line">127.0.0.1:6379&gt; HMSET user:001 username antirez password P1pp0 age 34 </div><div class="line">OK</div><div class="line">//列出哈希的内容</div><div class="line">127.0.0.1:6379&gt; HGETALL user:001 </div><div class="line">1) <span class="string">"username"</span></div><div class="line">2) <span class="string">"antirez"</span></div><div class="line">3) <span class="string">"password"</span></div><div class="line">4) <span class="string">"P1pp0"</span></div><div class="line">5) <span class="string">"age"</span></div><div class="line">6) <span class="string">"34"</span></div><div class="line">//更改哈希中的某一个值</div><div class="line">127.0.0.1:6379&gt; HSET user:001 password 12345 </div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">//再次列出哈希的内容</div><div class="line">127.0.0.1:6379&gt; HGETALL user:001 </div><div class="line">1) <span class="string">"username"</span></div><div class="line">2) <span class="string">"antirez"</span></div><div class="line">3) <span class="string">"password"</span></div><div class="line">4) <span class="string">"12345"</span></div><div class="line">5) <span class="string">"age"</span></div><div class="line">6) <span class="string">"34"</span></div></pre></td></tr></table></figure></p>
<p>有关hashes的操作，同样很丰富，需要时，大家可以从这里查询。</p>
<p></p><h3>redis持久化 – 两种方式</h3><br>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。<br>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；<br>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。<br>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。<br>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。<p></p>
<p></p><h4>redis持久化 – RDB</h4><br>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。<br>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。<br>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。<br>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<br>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。<p></p>
<p></p><h4>redis持久化 – AOF</h4><br>AOF，英文是Append Only File，即只允许追加不允许改写的文件。<br>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。<br>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。<br>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。<br>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。<br>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。<br>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。<br>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。<br>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。<br>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。<br>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.备份被写坏的AOF文件</div><div class="line">2.运行redis-check-aof –fix进行修复</div><div class="line">3.用diff -u来看下两个文件的差异，确认问题点</div><div class="line">4.重启redis，加载修复后的AOF文件</div></pre></td></tr></table></figure><p></p>
<p></p><h4>redis持久化 – AOF重写</h4><br>AOF重写的内部运行原理，我们有必要了解一下。<br>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。<br>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。<br>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。<br>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。<p></p>
<p></p><h4>redis持久化 – 如何选择RDB和AOF</h4><br>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。<p></p>
<p></p><h3>redis主从 – 用法</h3><br>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。<p></p>
<p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p>
<p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p>
<p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p>
<p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p>
<p></p><h3>redis主从 – 同步原理</h3><br>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。<p></p>
<p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p>
<p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p>
<p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p>
<p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p>
<p></p><h3>redis的事务处理</h3><br>众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。<p></p>
<p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p>
<p>1.MULTI用来组装一个事务；<br>2.EXEC用来执行一个事务；<br>3.DISCARD用来取消一个事务；<br>4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</p>
<p>纸上得来终觉浅，我们来看一个MULTI和EXEC的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">redis&gt; MULTI //标记事务开始</div><div class="line">OK</div><div class="line">redis&gt; INCR user_id //多条命令按顺序入队</div><div class="line">QUEUED</div><div class="line">redis&gt; INCR user_id</div><div class="line">QUEUED</div><div class="line">redis&gt; INCR user_id</div><div class="line">QUEUED</div><div class="line">redis&gt; PING</div><div class="line">QUEUED</div><div class="line">redis&gt; EXEC //执行</div><div class="line">1) (<span class="built_in">integer</span>) 1</div><div class="line">2) (<span class="built_in">integer</span>) 2</div><div class="line">3) (<span class="built_in">integer</span>) 3</div><div class="line">4) PONG</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，我们看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。</p>
<p>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</p>
<p>有关事务，大家经常会遇到的是两类错误：</p>
<p>1.调用EXEC之前的错误<br>2.调用EXEC之后的错误</p>
<p>“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; multi</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; haha //一个明显错误的指令</div><div class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">'haha'</span></div><div class="line">127.0.0.1:6379&gt; ping</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></div><div class="line">//redis无情的拒绝了事务的执行，原因是“之前出现了错误”</div><div class="line">(error) EXECABORT Transaction discarded because of previous errors.</div></pre></td></tr></table></figure></p>
<p>而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; multi</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 23</div><div class="line">QUEUED</div><div class="line">//age不是集合，所以如下是一条明显错误的指令</div><div class="line">127.0.0.1:6379&gt; sadd age 15 </div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 29</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> //执行事务时，redis不会理睬第2条指令执行错误</div><div class="line">1) OK</div><div class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</div><div class="line">3) OK</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line"><span class="string">"29"</span> //可以看出第3条指令被成功执行了</div></pre></td></tr></table></figure>
<p>好了，我们来说说最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</p>
<p>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 23</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; watch age //开始监视age</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 24 //在EXEC之前，age的值被修改了</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; multi</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 25</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> //触发EXEC</div><div class="line">(nil) //事务无法被执行</div></pre></td></tr></table></figure>
<p></p><h3>redis配置 – 简介</h3><br>我们可以在启动redis-server时指定应该加载的配置文件，方法如下：<p></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./redis-server /path/to/redis.conf</div></pre></td></tr></table></figure>
<p>接下来，我们就来讲解下redis配置文件的各个配置项的含义，注意，本文是基于redis-2.8.4版本进行讲解的。<br>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。<br>在配置文件的开头部分，首先明确了一些度量单位：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></div><div class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></div><div class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></div><div class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></div><div class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></div><div class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></div></pre></td></tr></table></figure>
<p>可以看出，redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。<br>redis支持“主配置文件中引入外部配置文件”，很像C/C++中的include指令，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include /path/to/other.conf</div></pre></td></tr></table></figure></p>
<p>如果你看过redis的配置文件，会发现还是很有条理的。redis配置文件被分成了几大块区域，它们分别是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.通用（general）</div><div class="line">2.快照（snapshotting）</div><div class="line">3.复制（replication）</div><div class="line">4.安全（security）</div><div class="line">5.限制（limits)</div><div class="line">6.追加模式（append only mode)</div><div class="line">7.LUA脚本（lua scripting)</div><div class="line">8.慢日志（slow <span class="built_in">log</span>)</div><div class="line">9.事件通知（event notification）</div></pre></td></tr></table></figure></p>
<p></p><h4>redis配置 -通用</h4><br>默认情况下，redis并不是以daemon形式来运行的。通过daemonize配置项可以控制redis的运行形式，如果改为yes，那么redis就会以daemon形式运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">daemonize no</div></pre></td></tr></table></figure><p></p>
<p>当以daemon形式运行时，redis会生成一个pid文件，默认会生成在/var/run/redis.pid。当然，你可以通过pidfile来指定pid文件生成的位置，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pidfile /path/to/redis.pid</div></pre></td></tr></table></figure></p>
<p>默认情况下，redis会响应本机所有可用网卡的连接请求。当然，redis允许你通过bind配置项来指定要绑定的IP，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span> 192.168.1.2 10.8.4.2</div></pre></td></tr></table></figure></p>
<p>redis的默认服务端口是6379，你可以通过port配置项来修改。如果端口设置为0的话，redis便不会监听端口了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">port 6379</div></pre></td></tr></table></figure></p>
<p>有些同学会问“如果redis不监听端口，还怎么与外界通信呢”，其实redis还支持通过unix socket方式来接收请求。可以通过unixsocket配置项来指定unix socket文件的路径，并通过unixsocketperm来指定文件的权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unixsocket /tmp/redis.sock</div><div class="line">unixsocketperm 755</div></pre></td></tr></table></figure></p>
<p>当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">timeout 0</div></pre></td></tr></table></figure></p>
<p>TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp-keepalive 0</div></pre></td></tr></table></figure></p>
<p>redis支持通过loglevel配置项设置日志等级，共分四级，即debug、verbose、notice、warning。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loglevel notice</div></pre></td></tr></table></figure></p>
<p>redis也支持通过logfile配置项来设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logfile <span class="string">""</span></div></pre></td></tr></table></figure></p>
<p>如果希望日志打印到syslog中，也很容易，通过syslog-enabled来控制。另外，syslog-ident还可以让你指定syslog里的日志标志，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">syslog-ident redis</div></pre></td></tr></table></figure></p>
<p>而且还支持指定syslog设备，值可以是USER或LOCAL0-LOCAL7。具体可以参考syslog服务本身的用法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">syslog-facility <span class="built_in">local</span>0</div></pre></td></tr></table></figure></p>
<p>对于redis来说，可以设置其数据库的总数量，假如你希望一个redis包含16个数据库，那么设置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">databases 16</div></pre></td></tr></table></figure></p>
<p>这16个数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select <dbid>来选择相应的数据库。</dbid></p>
<p></p><h4>redis配置 – 快照</h4><br>快照，主要涉及的是redis的RDB持久化相关的配置，我们来一起看一看。<br>我们可以用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save &lt;seconds&gt; &lt;changes&gt;</div></pre></td></tr></table></figure><p></p>
<p>举例来说：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1 //表示每15分钟且至少有1个key改变，就触发一次持久化</div><div class="line">save 300 10 //表示每5分钟且至少有10个key改变，就触发一次持久化</div><div class="line">save 60 10000 //表示每60秒至少有10000个key改变，就触发一次持久化</div></pre></td></tr></table></figure></p>
<p>如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save <span class="string">""</span></div></pre></td></tr></table></figure></p>
<p>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。<br>如果下一次RDB持久化成功，redis会自动恢复接受写请求。<br>当然，如果你不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，你完全可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。配置项如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop-writes-on-bgsave-error yes</div></pre></td></tr></table></figure></p>
<p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbcompression yes</div></pre></td></tr></table></figure></p>
<p>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果你希望获取到最大的性能提升，可以关闭此功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbchecksum yes</div></pre></td></tr></table></figure></p>
<p>我们还可以设置快照文件的名称，默认是这样配置的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dbfilename dump.rdb</div></pre></td></tr></table></figure></p>
<p>最后，你还可以设置这个快照文件存放的路径。比如默认设置就是当前文件夹：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir ./</div></pre></td></tr></table></figure></p>
<p></p><h4>redis配置 – 复制</h4><br>redis提供了主从同步功能。<br>通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</div></pre></td></tr></table></figure><p></p>
<p>如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">masterauth &lt;master-password&gt;</div></pre></td></tr></table></figure>
<p>当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：<br>第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。<br>第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。<br>你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。自从redis2.6版本之后，默认从redis为只读。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slave-read-only yes</div></pre></td></tr></table></figure></p>
<p>只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rename-command CONFIG b840<span class="built_in">fc</span>02d524045429941cc15f59e41cb7be6c52</div></pre></td></tr></table></figure></p>
<p>从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repl-ping-slave-period 10</div></pre></td></tr></table></figure></p>
<p>在主从同步时，可能在这些情况下会有超时发生：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.以从redis的角度来看，当有大规模IO传输时。</div><div class="line">2.以从redis的角度来看，当数据传输或PING时，主redis超时</div><div class="line">3.以主redis的角度来看，在回复从redis的PING时，从redis超时</div></pre></td></tr></table></figure></p>
<p>用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repl-timeout 60</div></pre></td></tr></table></figure></p>
<p>我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。（如果你不了解TCP_NODELAY，可以到这里来科普一下）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repl-disable-tcp-nodelay no</div></pre></td></tr></table></figure></p>
<p>我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repl-backlog-size 1mb</div></pre></td></tr></table></figure></p>
<p>如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repl-backlog-ttl 3600</div></pre></td></tr></table></figure></p>
<p>我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slave-priority 100</div></pre></td></tr></table></figure></p>
<p>假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，所以主redis能够了解每一个从redis的运行情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 3</div><div class="line">min-slaves-max-lag 10</div></pre></td></tr></table></figure></p>
<p>上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10</p>
<p></p><h4>redis配置 – 安全</h4><br>我们可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requirepass zhimakaimen</div></pre></td></tr></table></figure><p></p>
<p>这里我们通过requirepass将密码设置成“芝麻开门”。</p>
<p>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。比如可以把CONFIG命令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rename-command CONFIG b840<span class="built_in">fc</span>02d524045429941cc15f59e41cb7be6c89</div></pre></td></tr></table></figure></p>
<p>我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rename-command CONFIG <span class="string">""</span></div></pre></td></tr></table></figure></p>
<p>但需要注意的是，如果你使用AOF方式进行数据持久化，或者需要与从redis进行通信，那么更改指令的名字可能会引起一些问题。</p>
<p></p><h4>redis配置 -限制</h4><br>我们可以设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。<p></p>
<p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxclients 10000</div></pre></td></tr></table></figure></p>
<p>我们甚至可以设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者我们设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxmemory &lt;bytes&gt;</div></pre></td></tr></table></figure></p>
<p>需要注意的一点是，如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p>对于内存移除规则来说，redis提供了多达6种的移除规则。他们是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.volatile-lru：使用LRU算法移除过期集合中的key</div><div class="line">2.allkeys-lru：使用LRU算法移除key</div><div class="line">3.volatile-random：在过期集合中移除随机的key</div><div class="line">4.allkeys-random：移除随机的key</div><div class="line">5.volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。</div><div class="line">6.noeviction：不进行移除。针对写操作，只是返回错误信息。</div></pre></td></tr></table></figure></p>
<p>无论使用上述哪一种移除规则，如果没有合适的key可以移除的话，redis都会针对写请求返回错误信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxmemory-policy volatile-lru</div></pre></td></tr></table></figure></p>
<p>LRU算法和最小TTL算法都并非是精确的算法，而是估算值。所以你可以设置样本的大小。假如redis默认会检查三个key并选择其中LRU的那个，那么你可以改变这个key样本的数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxmemory-samples 3</div></pre></td></tr></table></figure></p>
<p>最后，我们补充一个信息，那就是到目前版本（2.8.4）为止，redis支持的写指令包括了如下这些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> setnx setex append</div><div class="line">incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</div><div class="line">sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</div><div class="line">zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</div><div class="line">getset mset msetnx <span class="built_in">exec</span> sort</div></pre></td></tr></table></figure></p>
<p><4>redis配置 – 追加模式<br>默认情况下，redis会异步的将数据持久化到磁盘。这种模式在大部分应用程序中已被验证是很有效的，但是在一些问题发生时，比如断电，则这种机制可能会导致数分钟的写请求丢失。</4></p>
<p>如博文上半部分中介绍的，追加文件（Append Only File）是一种更好的保持数据一致性的方式。即使当服务器断电时，也仅会有1秒钟的写请求丢失，当redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。</p>
<p>我们建议大家，AOF机制和RDB机制可以同时使用，不会有任何冲突。对于如何保持数据一致性的讨论，请参见本文。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly no</div></pre></td></tr></table></figure></p>
<p>我们还可以设置aof文件的名称：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendfilename <span class="string">"appendonly.aof"</span></div></pre></td></tr></table></figure></p>
<p>fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会“立即”进行，而另外一些操作系统则会“尽快”进行。</p>
<p>redis支持三种不同的模式：</p>
<p>1.no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。<br>2.always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。<br>3.everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</p>
<p>默认情况下为everysec。有关数据一致性的揭秘，可以参考本文。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendfsync everysec</div></pre></td></tr></table></figure></p>
<p>当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么redis可能会在fsync()调用时卡住。目前尚未修复这个问题，这是因为即使我们在另一个新的线程中去执行fsync()，也会阻塞住同步写调用。</p>
<p>为了缓解这个问题，我们可以使用下面的配置项，这样的话，当BGSAVE或BGWRITEAOF运行时，fsync()在主进程中的调用会被阻止。这意味着当另一路进程正在对AOF文件进行重构时，redis的持久化功能就失效了，就好像我们设置了“appendsync none”一样。如果你的redis有时延问题，那么请将下面的选项设置为yes。否则请保持no，因为这是保证数据完整性的最安全的选择。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">no-appendfsync-on-rewrite no</div></pre></td></tr></table></figure></p>
<p>我们允许redis自动重写aof。当aof增长到一定规模时，redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文件体积。</p>
<p>redis是这样工作的：redis会记录上次重写时的aof大小。假如redis自启动至今还没有进行过重写，那么启动时aof文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则会触发重写。另外，你还需要设置一个最小大小，是为了防止在aof很小时就触发重写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div></pre></td></tr></table></figure></p>
<p>如果设置auto-aof-rewrite-percentage为0，则会关闭此重写功能。</p>
<p></p><h4>redis配置 – LUA脚本</h4><br>lua脚本的最大运行时间是需要被严格限制的，要注意单位是毫秒：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lua-time-limit 5000</div></pre></td></tr></table></figure><p></p>
<p>如果此值设置为0或负数，则既不会有报错也不会有时间限制。</p>
<p></p><h4>redis配置 – 慢日志</h4><br>redis慢日志是指一个系统进行日志查询超过了指定的时长。这个时长不包括IO操作，比如与客户端的交互、发送响应内容等，而仅包括实际执行查询命令的时间。<p></p>
<p>针对慢日志，你可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。当一个新的命令被写入日志时，最老的一条会从命令日志队列中被移除。</p>
<p>单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表示强制记录每一个命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slowlog-log-slower-than 10000</div></pre></td></tr></table></figure></p>
<p>慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。你可以使用SLOWLOG RESET来重设这个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slowlog-max-len 128</div></pre></td></tr></table></figure></p>
<p></p><h4>redis配置 – 事件通知</h4><br>redis可以向客户端通知某些事件的发生。这个特性的具体解释可以参见本文。<p></p>
<p></p><h4>redis配置 – 高级配置</h4><br>有关哈希数据结构的一些配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">hash</span>-max-ziplist-entries 512</div><div class="line"><span class="built_in">hash</span>-max-ziplist-value 64</div></pre></td></tr></table></figure><p></p>
<p>有关列表数据结构的一些配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list-max-ziplist-entries 512</div><div class="line">list-max-ziplist-value 64</div></pre></td></tr></table></figure></p>
<p>有关集合数据结构的配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>-max-intset-entries 512</div></pre></td></tr></table></figure></p>
<p>有关有序集合数据结构的配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zset-max-ziplist-entries 128</div><div class="line">zset-max-ziplist-value 64</div></pre></td></tr></table></figure></p>
<p>关于是否需要再哈希的配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">activerehashing yes</div></pre></td></tr></table></figure></p>
<p>关于客户端输出缓冲的控制项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client-output-buffer-limit normal 0 0 0</div><div class="line">client-output-buffer-limit slave 256mb 64mb 60</div><div class="line">client-output-buffer-limit pubsub 32mb 8mb 60</div></pre></td></tr></table></figure></p>
<p>有关频率的配置项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hz 10</div></pre></td></tr></table></figure></p>
<p>有关重写aof的配置项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aof-rewrite-incremental-fsync yes</div></pre></td></tr></table></figure></p>
<p><strong><em>至此，redis的入门内容就结束了，内容实在不少，但相对来说都很基础，本文没有涉及redis集群、redis工作原理、redis源码、redis相关LIB库等内容，后续会陆续奉献，大家敬请期待</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。redis的官网地址，非常好记，是redis.io。（特意查了一下，域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地）目前，Vmware在资助着redis项目的开发和维护。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chen-hao.com.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://chen-hao.com.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>ELK + Kafka日志收集平台部署</title>
    <link href="http://chen-hao.com.cn/ELK-Kafka%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2.html"/>
    <id>http://chen-hao.com.cn/ELK-Kafka日志收集平台部署.html</id>
    <published>2016-10-14T01:10:19.000Z</published>
    <updated>2016-11-16T07:53:58.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近生产环境中准备使用ELK，于是自己动手开始搭建环境测试。<br> <a id="more"></a></p>
</blockquote>
<p></p><h2>ELK架构拓扑</h2><br><img src="/uploads/ELK配置.jpg" class="blockquote-center"> <p></p>
<ul>
<li>使用一台Nginx代理访问kibana的请求</li>
<li>两台es组成es集群，并且在两台es上面都安装kibana</li>
<li>中间三台服务器就是kafka(zookeeper)集群</li>
<li>最后面的就是一大堆的生产服务器，上面使用的是logstash</li>
</ul>
<h3>角色信息</h3>

<table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>操作系统</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>nginx-upstream</td>
<td>10.16.50.22</td>
<td>Centos 6.5 x64</td>
<td>反向代理至Kibana</td>
</tr>
<tr>
<td>es-kibana-1</td>
<td>10.16.50.16</td>
<td>Centos 6.5 x64</td>
<td>es集群+Kibana</td>
</tr>
<tr>
<td>es-kibana-2</td>
<td>10.16.50.17</td>
<td>Centos 6.5 x64</td>
<td>es集群+Kibana</td>
</tr>
<tr>
<td>kafka-zookeeper-1</td>
<td>10.16.50.19</td>
<td>Centos 6.5 x64</td>
<td>kafka+zookeeper集群</td>
</tr>
<tr>
<td>kafka-zookeeper-2</td>
<td>10.16.50.20</td>
<td>Centos 6.5 x64</td>
<td>kafka+zookeeper集群</td>
</tr>
<tr>
<td>kafka-zookeeper-3</td>
<td>10.16.60.21</td>
<td>Centos 6.5 x64</td>
<td>kafka+zookeeper集群</td>
</tr>
<tr>
<td>nginx-client</td>
<td>10.16.50.18</td>
<td>Centos 6.5 x64</td>
<td>模拟线上生产环境，产生日志</td>
</tr>
</tbody>
</table>
<p></p><h3>软件选用</h3><p></p>
<ul>
<li>elasticsearch-1.7.3.tar.gz</li>
<li>kibana-4.1.2-linux-x64.tar.gz</li>
<li>logstash-2.4.0.noarch.rpm</li>
</ul>
<p>以上软件均可从官网下载，<a href="https://www.elastic.co/downloads" target="_blank" rel="external">https://www.elastic.co/downloads</a></p>
<ul>
<li>nginx-1.8.1.tar.gz</li>
<li>jdk-8u101-linux-x64.rpm</li>
<li>kafka_2.11-0.8.2.1.tgz </li>
</ul>
<p></p><h3>部署步骤</h3><p></p>
<ol>
<li>ES集群安装配置</li>
<li>Logstash客户端配置(直接写入数据到ES集群，写入系统messages日志)</li>
<li>Kafka(zookeeper)集群配置;(Logstash写入数据到Kafka消息系统)</li>
<li>Kibana部署</li>
<li>Nginx负载均衡Kibana请求</li>
</ol>
<p></p><h2>ES集群安装配置</h2><br>所有服务器时间同步：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ntpdate 133.100.11.8</div></pre></td></tr></table></figure><p></p>
<p></p><h3>安装java-1.8.0以及依赖包</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">yum -y install jdk-8u101-linux-x64.rpm git</div><div class="line">vim /etc/profile.d/java.sh     <span class="comment">#配置java环境变量</span></div><div class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_101/</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></div><div class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</div><div class="line">. /etc/profile.d/java.sh       <span class="comment">#重载配置文件</span></div><div class="line">java -version                  <span class="comment">#检测jdk是否安装成功</span></div><div class="line">java version <span class="string">"1.8.0_101"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_101-b13)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)</div></pre></td></tr></table></figure><p></p>
<p></p><h3>安装elasticsearch软件包</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-1.7.3.tar.g</div><div class="line">tar -xf elasticsearch-1.7.3.tar.gz -C /usr/<span class="built_in">local</span></div><div class="line">ln -sv /usr/<span class="built_in">local</span>/elasticsearch-1.7.3 /usr/<span class="built_in">local</span>/elasticsearch</div></pre></td></tr></table></figure><p></p>
<p></p><h3>修改ES配置文件</h3><br>es_kibana-1 配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/elasticsearch/config/elasticsearch.yml</div><div class="line">cluster.name: es-cluster		<span class="comment">#组播的名称地址 </span></div><div class="line">node.name: <span class="string">"node1"</span>				<span class="comment">#节点名称，不能和其他节点重复</span></div><div class="line">node.master: <span class="literal">true</span>				<span class="comment">#节点能否被选举为master</span></div><div class="line">node.data: <span class="literal">true</span>					<span class="comment">#节点是否存储数据</span></div><div class="line">index.number_of_shards: 5		<span class="comment">#索引分片的个数</span></div><div class="line">index.number_of_replicas: 1		<span class="comment">#分片的副本个数</span></div><div class="line">path.data: /usr/<span class="built_in">local</span>/elasticsearch/config/		 <span class="comment">#配置文件的路径</span></div><div class="line">path.data: /work/es/data		<span class="comment">#数据目录路径</span></div><div class="line">path.work: /work/es/work		<span class="comment">#工作目录路径</span></div><div class="line">path.logs: /work/es/logs		<span class="comment">#日志文件路径</span></div><div class="line">path.plugins: /work/es/plugins	<span class="comment">#插件路径</span></div><div class="line">bootstrap.mlockall: <span class="literal">true</span>		<span class="comment">#内存不向swap交换</span></div><div class="line">http.port: 9200					<span class="comment">#启用http</span></div><div class="line"></div><div class="line">mkdir -pv /work/es/&#123;logs,data,plugins,work&#125;		<span class="comment">#创建所需要的工作目录</span></div><div class="line">git <span class="built_in">clone</span> https://github.com/elastic/elasticsearch-servicewrapper.git    </div><div class="line">mv elasticsearch-servicewrapper/service /usr/<span class="built_in">local</span>/elasticsearch/bin/</div><div class="line">/usr/<span class="built_in">local</span>/elasticsearch/bin/service/elasticsearch install</div><div class="line"><span class="comment">#这时就会在/etc/init.d/目录下安装上es的管理脚本啦</span></div><div class="line"><span class="comment">#修改其配置:</span></div><div class="line">vim /etc/init.d/elasticsearch</div><div class="line">ES_HOME=/usr/<span class="built_in">local</span>/elasticsearch</div></pre></td></tr></table></figure><p></p>
<p>es_kibana-2 的配置只需要把node.name和IP地址改一下即可</p>
<p></p><h3>检查其服务是否正常</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ss -tanl</div><div class="line"><span class="comment"># 确定9200和9300端口启动</span></div><div class="line"><span class="comment"># 9200：集群之间事务通信</span></div><div class="line"><span class="comment"># 9300：集群选举等</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>查看健康信息</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> curl -XGET <span class="string">'http://10.16.50.16:9200/_cluster/health?pretty'</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"cluster_name"</span> : <span class="string">"es-cluster"</span>,</div><div class="line">  <span class="string">"status"</span> : <span class="string">"green"</span>,</div><div class="line">  <span class="string">"timed_out"</span> : <span class="literal">false</span>,</div><div class="line">  <span class="string">"number_of_nodes"</span> : 2,</div><div class="line">  <span class="string">"number_of_data_nodes"</span> : 2,</div><div class="line">  <span class="string">"active_primary_shards"</span> : 0,</div><div class="line">  <span class="string">"active_shards"</span> : 0,</div><div class="line">  <span class="string">"relocating_shards"</span> : 0,</div><div class="line">  <span class="string">"initializing_shards"</span> : 0,</div><div class="line">  <span class="string">"unassigned_shards"</span> : 0,</div><div class="line">  <span class="string">"delayed_unassigned_shards"</span> : 0,</div><div class="line">  <span class="string">"number_of_pending_tasks"</span> : 0,</div><div class="line">  <span class="string">"number_of_in_flight_fetch"</span> : 0</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>查看节点数</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XGET <span class="string">'http://10.16.50.16:9200/_cat/nodes?v'</span></div><div class="line">host        ip          heap.percent ram.percent load node.role master name  </div><div class="line">es-kibana-1 10.16.50.16           10          17 0.30 d         m      node1 </div><div class="line">es-kibana-2 10.16.50.17           10          17 0.37 d         *      node2</div><div class="line"><span class="comment"># 由此可见，10.16.50.16已经成为主节点</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>安装head插件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/elasticsearch/bin/plugin -i mobz/elasticsearch-head</div></pre></td></tr></table></figure><p></p>
<p></p><h3>验证head插件</h3><br><img src="/uploads/ela_head.png" class="blockquote-center"> <p></p>
<ul>
<li>好了，es集群终于部署完成…</li>
</ul>
<p></p><h2>Logstash客户端安装配置</h2><br>在nginx_client上安装logstash<p></p>
<p></p><h3>安装依赖环境</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -y install jdk-8u101-linux-x64.rpm</div><div class="line"><span class="comment"># 配置环境变量同上</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>安装logstash</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install logstash-2.4.0.noarch.rpm</div></pre></td></tr></table></figure><p></p>
<p></p><h3>编写一个logstash配置文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vim /etc/logstash/conf.d/logstash_server.conf</div><div class="line">input &#123;</div><div class="line">    stdin &#123;&#125;		<span class="comment"># 数据的输入是标准输入</span></div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;	 <span class="comment"># 数据的输出是es集群</span></div><div class="line">    hosts =&gt; [<span class="string">"10.16.50.16:9200"</span>,<span class="string">"10.16.50.17:9200"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>检查配置文件是否有语法错误</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/opt/logstash/bin/logstash <span class="_">-f</span> /etc/logstash/conf.d/logstash_server.conf --configtest</div><div class="line">Configuration OK</div></pre></td></tr></table></figure><p></p>
<p></p><h3>启动logstash,并写入数据</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/opt/logstash/bin/logstash <span class="_">-f</span> /etc/logstash/conf.d/logstash_server.conf </div><div class="line"><span class="built_in">test</span> ELK</div><div class="line">chen-hao.com.cn</div></pre></td></tr></table></figure><p></p>
<p><img src="/uploads/ela_test.png" class="blockquote-center"><br>上图已经看到logstash已经可以正常工作了</p>
<p></p><h3>下面演示一下如何收集nginx日志信息</h3><br>这里为了省事，就直接yum安装nginx，安装完毕后并启动nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">vim /etc/logstash/conf.d/logstash_nginx.conf</div><div class="line">input &#123;</div><div class="line">     file &#123;</div><div class="line">        path =&gt; [<span class="string">"/var/log/nginx/access.log"</span>]	<span class="comment"># 这是日志文件的绝对路径</span></div><div class="line">        <span class="built_in">type</span> =&gt; <span class="string">"nginx_log"</span>						<span class="comment"># 日志类型</span></div><div class="line">        start_position =&gt; <span class="string">"beginning"</span>			<span class="comment"># 这个表示从messages的第一行读取</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; [<span class="string">"10.16.20.19:9200"</span>,<span class="string">"10.16.20.20:9200"</span>]</div><div class="line">    index =&gt; <span class="string">"system-messages-%&#123;+YYYY-MM&#125;"</span>		<span class="comment"># 这里将按照这个索引格式来创建索引</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>检测配置无误后，启动logstash，访问nginx网页，让我们再看head这个插件的web页面<br><img src="/uploads/ela_nginx.png" class="blockquote-center"> </p>
<ul>
<li>nginx日志我们已经成功的收集，并且已经写入到es集群中，那上面的演示是logstash直接将日志写入到es集群中的，这种场合我觉得如果量不是很大的话直接像上面已将将输出output定义到es集群即可，如果量大的话需要加上消息队列来缓解es集群的压力。前面已经提到了我这边之前使用的是单台redis作为消息队列，但是redis不能作为list类型的集群，也就是redis单点的问题没法解决，所以这里我选用了kafka ;</li>
</ul>
<p></p><h2>Kafka集群安装配置</h2><br>搭建kafka集群时，需要提前安装zookeeper集群（同样需要依赖jdk），当然kafka已经自带zookeeper程序只需要解压并且安装配置就行了<p></p>
<p></p><h3>解压软件包（3个节点都需要配置）</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget http://mirror.rise.ph/apache/kafka/0.8.2.1/kafka_2.11-0.8.2.1.tgz</div><div class="line">tar -zxf kafka_2.11-0.8.2.1.tgz -C /usr/<span class="built_in">local</span>/</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</div><div class="line">ln -sv kafka_2.11-0.8.2.1 kafka</div></pre></td></tr></table></figure><p></p>
<p>配置hosts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/hosts</div><div class="line">10.16.50.19     kafka-zookeeper-1</div><div class="line">10.16.50.20     kafka-zookeeper-2</div><div class="line">10.16.50.21     kafka-zookeeper-3</div></pre></td></tr></table></figure></p>
<p></p><h3>配置zookeeper集群，修改配置文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/kafka/config/zookeeper.propertie</div><div class="line">dataDir=/work/zookeeper</div><div class="line">clientPort=2181</div><div class="line">maxClientCnxns=0</div><div class="line">tickTime=2000</div><div class="line">initLimit=20</div><div class="line">syncLimit=10</div><div class="line">server.2=10.16.50.19:2888:3888</div><div class="line">server.3=10.16.50.20:2888:3888</div><div class="line">server.4=10.16.50.21:2888:3888</div><div class="line"></div><div class="line"><span class="comment"># 说明：</span></div><div class="line"><span class="comment"># tickTime: 这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</span></div><div class="line"><span class="comment"># 2888端口：表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；</span></div><div class="line"><span class="comment"># 3888端口：表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>创建zookeeper所需要目录及文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir /work/zookeeper</div><div class="line"><span class="comment"># 在/work/zookeeper目录下创建myid文件，里面的内容为数字，用于标识主机，如果这个文件没有的话，zookeeper是没法启动的</span></div><div class="line"><span class="built_in">echo</span> 2 &gt; /work/zookeeper/myid</div><div class="line"><span class="comment"># 另外两个节点分别替换为3 、 4 即可</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>kafka配置</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/kafka/config/server.properties</div><div class="line">broker.id=2									<span class="comment"># 唯一，填数字，本文中分别为2/3/4</span></div><div class="line">port=9092</div><div class="line">host.name=10.16.50.19</div><div class="line">log.dirs=/work/kafka-logs					<span class="comment"># 该目录可以不用提前创建，在启动时自己会创建</span></div><div class="line">zookeeper.connect=10.16.50.19:2181,10.16.50.20:2181,10.16.50.21:2181</div><div class="line">num.partitions=16							<span class="comment"># 需要配置较大 分片影响读写速度</span></div><div class="line">log.retention.hours=168						<span class="comment"># 时间按需求保留过期时间 避免磁盘满</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>修改完毕配置之后我们就可以启动了，这里先要启动zookeeper集群，才能启动kafka</h3><br>启动顺序分别为 kafka1 –&gt; kafka2 –&gt;kafka3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/zookeeper-server-start.sh /usr/<span class="built_in">local</span>/kafka/config/zookeeper.properties &amp;	<span class="comment"># 启动命令</span></div><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/zookeeper-server-stop.sh	<span class="comment"># 停止命令</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>zookeeper服务检查</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@kafka-zookeeper-1 zookeeper]<span class="comment"># netstat -nlpt | grep -E "2181|2888|3888"</span></div><div class="line">tcp        0      0 ::ffff:10.16.20.21:3888     :::*                        LISTEN      12223/java          </div><div class="line">tcp        0      0 :::2181                     :::*                        LISTEN      12223/java </div><div class="line"></div><div class="line">[root@kafka-zookeeper-2 work]<span class="comment"># netstat -nlpt | grep -E "2181|2888|3888"</span></div><div class="line">tcp        0      0 ::ffff:10.16.20.22:3888     :::*                        LISTEN      10370/java          </div><div class="line">tcp        0      0 :::2181                     :::*                        LISTEN      10370/java          </div><div class="line">tcp        0      0 ::ffff:10.16.20.22:2888     :::*                        LISTEN      10370/java  </div><div class="line"></div><div class="line">[root@kafka-zookeeper-3 work]<span class="comment"># netstat -nlpt | grep -E "2181|2888|3888"</span></div><div class="line">tcp        0      0 ::ffff:10.16.20.24:3888     :::*                        LISTEN      10329/java          </div><div class="line">tcp        0      0 :::2181                     :::*                        LISTEN      10329/java   </div><div class="line"><span class="comment"># 可以看出，如果哪台是Leader,那么它就拥有2888这个端口</span></div></pre></td></tr></table></figure><p></p>
<p>ok.  这时候zookeeper集群已经启动起来了，下面启动kafka，也是依次按照顺序启动</p>
<p></p><h3>启动kafka</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nohup /usr/<span class="built_in">local</span>/kafka/bin/kafka-server-start.sh /usr/<span class="built_in">local</span>/kafka/config/server.properties &amp;</div><div class="line">cat nohup.log   确认没有报错信息</div></pre></td></tr></table></figure><p></p>
<p>此时三台上面的zookeeper及kafka都已经启动完毕，来检测以下吧</p>
<p></p><h3>建立一个主题</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic <span class="built_in">test</span>_ch</div></pre></td></tr></table></figure><p></p>
<p></p><h3>查看有哪些主题已经创建</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --list --zookeeper 10.16.50.20:2181</div><div class="line"><span class="built_in">test</span>_ch</div></pre></td></tr></table></figure><p></p>
<p></p><h3>查看test_ch这个主题的详情</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --describe --zookeeper 10.16.50.20:2181 --topic <span class="built_in">test</span>_ch</div><div class="line">Topic:<span class="built_in">test</span>_ch	PartitionCount:1	ReplicationFactor:3	Configs:</div><div class="line">	Topic: <span class="built_in">test</span>_ch	Partition: 0	Leader: 4	Replicas: 4,3,2	Isr: 4,3,2</div><div class="line"></div><div class="line"><span class="comment"># 主题名称：test_ch</span></div><div class="line"><span class="comment"># Partition:只有一个，从0开始</span></div><div class="line"><span class="comment"># leader ：id为4的broker</span></div><div class="line"><span class="comment"># Replicas 副本存在于broker id为2,3,4的上面</span></div><div class="line"><span class="comment"># Isr:活跃状态的broker</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>我们在zk2上，开一个终端，发送消息至kafka（zk2模拟生产者）</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@kafka-zookeeper-2 ~]<span class="comment"># /usr/local/kafka/bin/kafka-console-producer.sh --broker-list 10.16.50.19:9092 --sync --topic test_ch</span></div><div class="line">123456</div><div class="line"><span class="built_in">test</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>我们在zk3上，开一个终端，显示消息的消费（zk3模拟消费者）</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@kafka-zookeeper-3 ~]<span class="comment"># /usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper 10.16.50.19:2181 --topic test_ch --from-beginning</span></div><div class="line"><span class="built_in">test</span> </div><div class="line">12344567</div></pre></td></tr></table></figure><p></p>
<p>如果能够像上面一样能够接收到生产者发过来的消息，那说明基于kafka的zookeeper集群就成功啦</p>
<p></p><h3>下面我们将nginx-client上面的logstash的输出改到kafka上面，将数据写入到kafka中</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vim /etc/logstash/conf.d/logstash_kafka.conf</div><div class="line">input &#123;</div><div class="line">  file &#123;</div><div class="line">    <span class="built_in">type</span> =&gt; <span class="string">"system-message"</span></div><div class="line">    path =&gt; <span class="string">"/var/log/messages"</span></div><div class="line">    start_position =&gt; <span class="string">"beginning"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">    stdout &#123; codec =&gt; rubydebug &#125;</div><div class="line">    kafka &#123;</div><div class="line">      bootstrap_servers =&gt; <span class="string">"10.16.50.19:9092,10.16.50.19:9092,10.16.50.19:9092"</span></div><div class="line">      topic_id =&gt; <span class="string">"system-messages"</span></div><div class="line">      compression_<span class="built_in">type</span> =&gt; <span class="string">"snappy"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>检测配置并运行</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/opt/logstash/bin/logstash <span class="_">-f</span> /etc/logstash/conf.d/logstash_kafka.conf --configtest --verbose</div><div class="line">/opt/logstash/bin/logstash <span class="_">-f</span> /etc/logstash/conf.d/logstash_kafka.conf</div></pre></td></tr></table></figure><p></p>
<p></p><h3>验证数据是否写入到kafka，这里我们检查是否生成了一个叫system-messages的主题</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --list --zookeeper 10.16.50.19:2181</div><div class="line">summer</div><div class="line">system-messages</div><div class="line"><span class="built_in">test</span>_ch</div><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --describe --zookeeper 10.16.50.19:2181 --topic system-messages</div><div class="line">Topic:system-messages	PartitionCount:8	ReplicationFactor:1	Configs:</div><div class="line">	Topic: system-messages	Partition: 0	Leader: 3	Replicas: 3	Isr: 3</div><div class="line">	Topic: system-messages	Partition: 1	Leader: 4	Replicas: 4	Isr: 4</div><div class="line">	Topic: system-messages	Partition: 2	Leader: 2	Replicas: 2	Isr: 2</div><div class="line">	Topic: system-messages	Partition: 3	Leader: 3	Replicas: 3	Isr: 3</div><div class="line">	Topic: system-messages	Partition: 4	Leader: 4	Replicas: 4	Isr: 4</div><div class="line">	Topic: system-messages	Partition: 5	Leader: 2	Replicas: 2	Isr: 2</div><div class="line">	Topic: system-messages	Partition: 6	Leader: 3	Replicas: 3	Isr: 3</div><div class="line">	Topic: system-messages	Partition: 7	Leader: 4	Replicas: 4	Isr: 4</div><div class="line">	Topic: system-messages	Partition: 8	Leader: 2	Replicas: 2	Isr: 2</div><div class="line">	Topic: system-messages	Partition: 9	Leader: 3	Replicas: 3	Isr: 3</div><div class="line">	Topic: system-messages	Partition: 10	Leader: 4	Replicas: 4	Isr: 4</div><div class="line">	Topic: system-messages	Partition: 11	Leader: 2	Replicas: 2	Isr: 2</div><div class="line">	Topic: system-messages	Partition: 12	Leader: 3	Replicas: 3	Isr: 3</div><div class="line">	Topic: system-messages	Partition: 13	Leader: 4	Replicas: 4	Isr: 4</div><div class="line">	Topic: system-messages	Partition: 14	Leader: 2	Replicas: 2	Isr: 2</div><div class="line">	Topic: system-messages	Partition: 15	Leader: 3	Replicas: 3	Isr: 3</div></pre></td></tr></table></figure><p></p>
<ul>
<li>可以看出，这个主题生成了16个分区，每个分区都有对应自己的Leader，但是我想要有10个分区，3个副本如何办？还是跟我们上面一样命令行来创建主题就行，当然对于logstash输出的我们也可以提前先定义主题，然后启动logstash 直接往定义好的主题写数据就行啦，命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/kafka/bin/kafka-topics.sh --create --zookeeper 10.16.20.21:2181 --replication-factor 3 --partitions 10 --topic TOPIC_NAME</div></pre></td></tr></table></figure>
<ul>
<li>我们将logstash收集到的数据写入到了kafka中了，在实验过程中我使用while脚本测试了如果不断的往kafka写数据的同时停掉两个节点，数据写入没有任何问题。</li>
</ul>
<p>那如何将数据从kafka中读取然后给我们的es集群呢？那下面我们在kafka集群上安装Logstash，安装步骤不再赘述；三台上面的logstash 的配置如下，作用是将kafka集群的数据读取然后转交给es集群，这里为了测试我让他新建一个索引文件，注意这里的输入日志还是messages，主题名称还是“system-messages”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vim /etc/logstash/conf.d/logstash_es.conf</div><div class="line">input &#123;</div><div class="line">    kafka &#123;</div><div class="line">        zk_connect =&gt; <span class="string">"10.16.50.19:2181,10.16.50.20:2181,10.16.50.21:2181"</span></div><div class="line">        topic_id =&gt; <span class="string">"system-messages"</span></div><div class="line">        codec =&gt; plain</div><div class="line">        reset_beginning =&gt; <span class="literal">false</span></div><div class="line">        consumer_threads =&gt; 5</div><div class="line">        decorate_events =&gt; <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">      hosts =&gt; [<span class="string">"10.16.50.16:9200"</span>,<span class="string">"10.16.50.17:9200"</span>]</div><div class="line">      index =&gt; <span class="string">"test-system-messages-%&#123;+YYYY-MM&#125;"</span></div><div class="line">  &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p></p><h3>在三台kafka上面启动Logstash</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/logstash/bin/logstash <span class="_">-f</span> /etc/logstash/conf.d/logstash_es.conf</div></pre></td></tr></table></figure><p></p>
<p>在nginx-client上写入测试内容，即nginx-client上面利用message这个文件来测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@nginx-client work]<span class="comment"># echo 'chen-hao.com.cn' &gt;&gt; /var/log/messages</span></div><div class="line">[root@nginx-client work]<span class="comment"># echo 'ELK部署集群' &gt;&gt; /var/log/messages</span></div></pre></td></tr></table></figure></p>
<p>客户端写入到kafka集群的同时也将其输入到终端，这里写入了2条内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       &quot;message&quot; =&gt; &quot;chen-hao.com.cn&quot;,</div><div class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</div><div class="line">    &quot;@timestamp&quot; =&gt; &quot;2016-11-16T06:18:32.565Z&quot;,</div><div class="line">          &quot;path&quot; =&gt; &quot;/var/log/messages&quot;,</div><div class="line">          &quot;host&quot; =&gt; &quot;0.0.0.0&quot;,</div><div class="line">          &quot;type&quot; =&gt; &quot;system-message&quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">       &quot;message&quot; =&gt; &quot;ELK部署集群&quot;,</div><div class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</div><div class="line">    &quot;@timestamp&quot; =&gt; &quot;2016-11-16T06:18:46.584Z&quot;,</div><div class="line">          &quot;path&quot; =&gt; &quot;/var/log/messages&quot;,</div><div class="line">          &quot;host&quot; =&gt; &quot;0.0.0.0&quot;,</div><div class="line">          &quot;type&quot; =&gt; &quot;system-message&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h3>接下来可以看看我们的es管理界面</h3><br><img src="/uploads/ela_kafka.png" class="blockquote-center"> <p></p>
<p>OK,我们的E+L部署完毕</p>
<p></p><h2>Kibana部署</h2><br>Kibana的作用，就是一个展示工具，报表内容非常的丰富，下面我们在两台es上面搭建两套kibana<p></p>
<p></p><h3>安装kibana软件包</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> wget https://download.elastic.co/kibana/kibana/kibana-4.1.2-linux-x64.tar.gz</div><div class="line">tar -zxf kibana-4.1.2-linux-x64.tar.gz -C /usr/<span class="built_in">local</span>/</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</div><div class="line">ln -sv kibana-4.1.2-linux-x64 kibana</div><div class="line"></div><div class="line">&lt;h3&gt;修改配置文件&lt;/h3&gt;</div><div class="line">```bash</div><div class="line">vim /usr/<span class="built_in">local</span>/kibana/config/kibana.yml</div><div class="line">server.port: 5601      <span class="comment">#默认端口可以修改的</span></div><div class="line">server.host: <span class="string">"0.0.0.0"</span> <span class="comment">#kibana监听的ip</span></div><div class="line">elasticsearch.url: <span class="string">"http://localhost:9200"</span> <span class="comment">#由于es在本地主机上面，所以这个选项打开注释即可</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>提供kibana服务管理脚本</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">cat /etc/init.d/kibana</div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#chkconfig: 2345 55 24</span></div><div class="line"><span class="comment">#description: kibana service manager</span></div><div class="line"> </div><div class="line">KIBBIN=<span class="string">'/usr/local/kibana/bin/kibana'</span></div><div class="line">LOCK=<span class="string">'/usr/local/kibana/locks'</span></div><div class="line"> </div><div class="line"><span class="function"><span class="title">START</span></span>() &#123;</div><div class="line">	<span class="keyword">if</span> [ <span class="_">-f</span> <span class="variable">$LOCK</span> ];<span class="keyword">then</span></div><div class="line">		<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"kibana is already \033[32mrunning\033[0m, do nothing."</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"Start kibana service.\033[32mdone\033[m"</span></div><div class="line">		<span class="built_in">cd</span>  /usr/<span class="built_in">local</span>/kibana/bin</div><div class="line">    	nohup ./kibana &amp; &gt;/dev/null</div><div class="line"> 		touch <span class="variable">$LOCK</span></div><div class="line">	<span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="title">STOP</span></span>() &#123;</div><div class="line">	<span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="variable">$LOCK</span> ];<span class="keyword">then</span></div><div class="line">		<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"kibana is already stop, do nothing."</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"Stop kibana serivce \033[32mdone\033[m"</span></div><div class="line">		rm -rf <span class="variable">$LOCK</span></div><div class="line">		ps -ef | grep kibana | grep -v <span class="string">"grep"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> <span class="_">-s</span> 9 &gt;/dev/null</div><div class="line">	<span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="title">STATUS</span></span>() &#123;</div><div class="line">        Port=$(netstat -tunl | grep <span class="string">":5602"</span>)</div><div class="line">	<span class="keyword">if</span> [ <span class="string">"<span class="variable">$Port</span>"</span> != <span class="string">""</span> ] &amp;&amp; [ <span class="_">-f</span> <span class="variable">$LOCK</span> ];<span class="keyword">then</span></div><div class="line">		<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"kibana is: \033[32mrunning\033[0m..."</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"kibana is: \033[31mstopped\033[0m..."</span></div><div class="line">	<span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">  start)</div><div class="line">	START</div><div class="line">	;;</div><div class="line">  stop)</div><div class="line">	STOP</div><div class="line">	;;</div><div class="line">  status)</div><div class="line">	STATUS</div><div class="line">	;;</div><div class="line">  restart)</div><div class="line">	STOP </div><div class="line">    sleep 2</div><div class="line">    START</div><div class="line">	;;</div><div class="line">  *)</div><div class="line">	<span class="built_in">echo</span> <span class="string">"Usage: /etc/init.d/kibana (|start|stop|status|restart)"</span></div><div class="line">	;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure><p></p>
<p></p><h3>启动kibana服务</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chkconfig --add kibana</div><div class="line">service kibana start</div></pre></td></tr></table></figure><p></p>
<p></p><h3>访问kibana页面</h3><br><img src="/uploads/ela_k.png" class="blockquote-center"><br>能成功的访问5601端口，那我把es1这台的配置放到es2上面去然后启动，效果跟访问es1一样<p></p>
<p></p><h2>Nginx负载均衡kibana的请求</h2><br>在nginx-upstream上安装nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install nginx</div></pre></td></tr></table></figure><p></p>
<p></p><h3>编写配置文件nginx.conf</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vim /etc/nginx/nginx.conf</div><div class="line">upstream es &#123;</div><div class="line">    server 10.16.50.17:5601 max_fails=3 fail_timeout=30s;</div><div class="line">    server 10.16.50.16:5601 max_fails=3 fail_timeout=30s;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"> </div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://es/;</div><div class="line">        index index.html index.htm;</div><div class="line">        <span class="comment">#auth</span></div><div class="line">        auth_basic <span class="string">"ELK Private"</span>;</div><div class="line">        auth_basic_user_file /etc/nginx/.htpasswd;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>创建认证</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">htpasswd -cm /etc/nginx/.htpasswd elk</div><div class="line">New password: </div><div class="line">Re-type new password: </div><div class="line">Adding password <span class="keyword">for</span> user elk</div><div class="line">nginx -t &amp;&amp; nginx <span class="_">-s</span> restart     <span class="comment">#检测并启动nginx</span></div></pre></td></tr></table></figure><p></p>
<p>入认证用户及密码就可访问<a href="http://10.16.50.22/" target="_blank" rel="external">http://10.16.50.22/</a></p>
<ul>
<li>基本上ELK集群算是安装完毕，那么在下次将介绍线上各种日志的方法和方式</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近生产环境中准备使用ELK，于是自己动手开始搭建环境测试。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://chen-hao.com.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ELK" scheme="http://chen-hao.com.cn/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置与优化</title>
    <link href="http://chen-hao.com.cn/nginx%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96.html"/>
    <id>http://chen-hao.com.cn/nginx配置与优化.html</id>
    <published>2016-10-10T03:40:52.000Z</published>
    <updated>2016-10-10T05:54:17.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Nginx作为一个非常流行和成熟的Web Server和Reserve Proxy Server，网上有大量的性能优化教程，但是不同的业务场景千差万别，什么配置是最适合自己的，还是只有基于自己的业务才能配置出适合自己的参数。<br> <a id="more"></a></p>
</blockquote>
<p></p><h2>nginx的安装</h2><p></p>
<p></p><h3>自动安装</h3><br>这里我们可以直接配置好官方yum源，直接yum安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo</div><div class="line">baseurl=http://nginx.org/packages/centos/6/<span class="variable">$basearch</span>/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"><span class="comment"># 确认yum源无误后直接yum安装即可</span></div><div class="line">yum -y install nginx</div></pre></td></tr></table></figure><p></p>
<p></p><h3>编译安装</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 检查和安装依赖项（gcc、正则表达式工具、传送内容压缩的zlib库、openssl开启https支持），-y表示静默安装</span></div><div class="line">yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</div><div class="line"></div><div class="line"><span class="comment"># 下载源码包</span></div><div class="line">wget http://nginx.org/download/nginx-1.8.0.tar.gz</div><div class="line"></div><div class="line"><span class="comment"># 解压源码包</span></div><div class="line">tar zxvf nginx-1.8.0.tar.gz</div><div class="line"></div><div class="line"><span class="comment"># 进入解压的目录配置相关参数（可以使用--help查看可选项）</span></div><div class="line"><span class="built_in">cd</span> nginx-1.8.0/</div><div class="line">./configure \</div><div class="line">	--prefix=/usr/<span class="built_in">local</span>    							<span class="comment">#安装路径</span></div><div class="line">	--sbin-path=/usr/sbin/nginx      				<span class="comment">#程序文件安装路径</span></div><div class="line">	--conf-path=/etc/nginx/nginx.conf      			<span class="comment">#主配置文件安装路径</span></div><div class="line">	--error-log-path=/var/<span class="built_in">log</span>/nginx/error.log    	<span class="comment">#错误日志文件的路径</span></div><div class="line">	--http-log-path=/var/<span class="built_in">log</span>/nginx/access.log    	<span class="comment">#访问日志文件的路径</span></div><div class="line">	--pid-path=/var/run/nginx.pid   				<span class="comment">#pid文件的路径</span></div><div class="line">	--lock-path=/var/run/nginx.lock  				<span class="comment">#锁文件的路径</span></div><div class="line">	--http-client-body-temp-path=/var/cache/nginx/client_temp   <span class="comment">#客户端body部分临时文件存放路径</span></div><div class="line">	--http-proxy-temp-path=/var/cache/nginx/proxy_temp       </div><div class="line">	--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp</div><div class="line">	--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp</div><div class="line">	--http-scgi-temp-path=/var/cache/nginx/scgi_temp</div><div class="line">	--user=nginx     								<span class="comment">#以nginx属主运行worker进程</span></div><div class="line">	--group=nginx    								<span class="comment">#以nginx属组运行worker进程</span></div><div class="line">	--with-http_ssl_module      					<span class="comment">#SSL模块，需安装OPENSSL</span></div><div class="line">	--with-http_realip_module</div><div class="line">	--with-http_addition_module</div><div class="line">	--with-http_sub_module</div><div class="line">	--with-http_dav_module</div><div class="line">	--with-http_flv_module      					<span class="comment">#启用ngx_http_flv模块</span></div><div class="line">	--with-http_mp4_module</div><div class="line">	--with-http_gunzip_module</div><div class="line">	--with-http_gzip_static_module    				<span class="comment">#启用需要依赖zlib</span></div><div class="line">	--with-http_random_index_module</div><div class="line">	--with-http_secure_link_module</div><div class="line">	--with-http_stub_status_module      			<span class="comment">#启用server status页面</span></div><div class="line">	--with-http_auth_request_module</div><div class="line">	--with-threads</div><div class="line">	--with-stream</div><div class="line">	--with-stream_ssl_module</div><div class="line">	--with-http_slice_module</div><div class="line">	--with-file-aio</div><div class="line">	--with-http_v2_module</div><div class="line">	--with-debug       								<span class="comment">#打开调试机制</span></div><div class="line"></div><div class="line"><span class="comment"># 安装</span></div><div class="line">make &amp;&amp; make install</div><div class="line"></div><div class="line"><span class="comment"># 启动和关闭nginx</span></div><div class="line"><span class="built_in">cd</span> /opt/nginx/sbin/</div><div class="line">./nginx</div><div class="line"></div><div class="line">ps -aux|grep nginx <span class="comment"># 查看进程（正常工作的时候有守护进程和工作进程）</span></div><div class="line"></div><div class="line">./nginx -h <span class="comment"># 查看帮助</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>nginx的配置</h2><br>nginx的主配置文件位于安装目录下的<strong>conf/nginx.conf</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 指明worker的进程数；通常应该为CPU的核心数减1</span></div><div class="line">worker_processes  7;</div><div class="line"></div><div class="line"><span class="comment"># event指令与事件模型有关，配置处理连接有关信息</span></div><div class="line">events &#123;</div><div class="line"><span class="comment"># 单个worker进程所能够并发打开的最大连接数；默认为1024</span></div><div class="line"><span class="comment"># 当前主机能响应最大并发连接数：worker_processes * worker_connections</span></div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># http指令处理http请求</span></div><div class="line">http &#123;</div><div class="line">    <span class="comment"># mime type映射</span></div><div class="line">    include       mime.types;</div><div class="line">    default_<span class="built_in">type</span>  application/octet-stream;</div><div class="line">    sendfile        on;</div><div class="line">    <span class="comment">#tcp_nopush     on;</span></div><div class="line">    <span class="comment">#keepalive_timeout  0;</span></div><div class="line">    keepalive_timeout  65;</div><div class="line">    <span class="comment">#gzip  on;</span></div><div class="line">    <span class="comment"># server 表示一个虚拟主机，一台服务器可配置多个虚拟主机</span></div><div class="line">    server &#123;</div><div class="line">        <span class="comment"># 监听端口</span></div><div class="line">        listen       80;</div><div class="line">        <span class="comment"># 识别的域名</span></div><div class="line">        server_name  localhost;</div><div class="line">        <span class="comment"># 一个关键设置，与url参数乱码问题有关</span></div><div class="line">        charset utf-8;</div><div class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></div><div class="line">        <span class="comment">#location表达式：</span></div><div class="line">        <span class="comment">#syntax: location [=|~|~*|^~|@] /uri/ &#123; … &#125;</span></div><div class="line">        <span class="comment">#分为两种匹配模式，普通字符串匹配，正则匹配</span></div><div class="line">        <span class="comment">#无开头引导字符或以=开头表示普通字符串匹配</span></div><div class="line">        <span class="comment">#以~或~* 开头表示正则匹配，~*表示不区分大小写</span></div><div class="line">        <span class="comment">#多个location时匹配规则</span></div><div class="line">        <span class="comment">#总体是先普通后正则原则，只识别URI部分，例如请求为/test/1/abc.do?arg=xxx</span></div><div class="line">        <span class="comment">#1. 先查找是否有=开头的精确匹配，即location = /test/1/abc.do &#123;...&#125;</span></div><div class="line">        <span class="comment">#2. 再查找普通匹配，以 最大前缀 为规则，如有以下两个location</span></div><div class="line">        <span class="comment">#   location /test/ &#123;...&#125;</span></div><div class="line">        <span class="comment">#   location /test/1/ &#123;...&#125;</span></div><div class="line">        <span class="comment">#   则匹配后一项</span></div><div class="line">        <span class="comment">#3. 匹配到一个普通格式后，搜索并未结束，而是暂存当前结果，并继续再搜索正则模式</span></div><div class="line">        <span class="comment">#4. 在所有正则模式location中找到第一个匹配项后，以此匹配项为最终结果</span></div><div class="line">        <span class="comment">#   所以正则匹配项匹配规则受定义前后顺序影响，但普通匹配不会</span></div><div class="line">        <span class="comment">#5. 如果未找到正则匹配项，则以3中缓存的结果为最终结果</span></div><div class="line">        <span class="comment">#6. 如果一个匹配都没有，返回404</span></div><div class="line">        <span class="comment">#location =/ &#123;...&#125; 与 location / &#123;...&#125; 的差别</span></div><div class="line">        <span class="comment">#前一个是精确匹配，只响应/请求，所有/xxx类请求不会以前缀匹配形式匹配到它</span></div><div class="line">        <span class="comment">#而后一个正相反，所有请求必然都是以/开头，所以没有其它匹配结果时一定会执行到它</span></div><div class="line">        <span class="comment">#location ^~ / &#123;...&#125; ^~意思是非正则，表示匹配到此模式后不再继续正则搜索</span></div><div class="line">        <span class="comment">#所有如果这样配置，相当于关闭了正则匹配功能</span></div><div class="line">        <span class="comment">#因为一个请求在普通匹配规则下没得到其它普通匹配结果时，最终匹配到这里</span></div><div class="line">        <span class="comment">#而这个^~指令又相当于不允许正则，相当于匹配到此为止</span></div><div class="line">        location / &#123;</div><div class="line">            root   html; <span class="comment"># 网站根目录，默认是安装目录下的html目录（可以指定绝对路径）</span></div><div class="line">            index  index.html index.htm;</div><div class="line">            <span class="comment"># deny all; 拒绝请求，返回403</span></div><div class="line">            <span class="comment"># allow all; 允许请求</span></div><div class="line">        &#125;</div><div class="line">        location /<span class="built_in">test</span>/ &#123;</div><div class="line">            deny all;</div><div class="line">        &#125;</div><div class="line">        location ~ /<span class="built_in">test</span>/.+\.jsp$ &#123;</div><div class="line">           <span class="comment"># proxy_pass表示代理</span></div><div class="line">           proxy_pass  http://192.168.132.144:8080;</div><div class="line">        &#125;</div><div class="line">        location ~ \.jsp$ &#123;</div><div class="line">           proxy_pass  http://192.168.132.144:8080;</div><div class="line">        &#125;</div><div class="line">        <span class="comment"># 定义各类错误页</span></div><div class="line">        error_page  404              /404.html;</div><div class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></div><div class="line">        <span class="comment">#</span></div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line">        <span class="comment"># @类似于变量定义</span></div><div class="line">        <span class="comment"># error_page 403 http://www.jikexueyuan.com这种定义不允许，所以利用@实现</span></div><div class="line">        error_page 403 @page403;</div><div class="line">        location @page403 &#123;</div><div class="line">            proxy_pass http://http://www.jikexueyuan.com;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        <span class="comment">#listen 9090</span></div><div class="line">        server_name  www.test.com test.com other.cc;</div><div class="line">        location / &#123;</div><div class="line">            <span class="comment"># root d:\\test; 注意，win下d:\test因转义符问题不允许</span></div><div class="line">            root d:/<span class="built_in">test</span></div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h2>nginx的优化</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nginx不同于apache服务器，当进行了大量优化设置后会魔术般的明显性能提升效果</span></div><div class="line"><span class="comment"># nginx在安装完成后，大部分参数就已经是最优化了，我们需要管理的东西并不多</span></div><div class="line"><span class="comment">#user  nginx;</span></div><div class="line"></div><div class="line"><span class="comment"># 阻塞和非阻塞网络模型：</span></div><div class="line"><span class="comment"># 同步阻塞模型，一请求一进（线）程，当进（线）程增加到一定程度后</span></div><div class="line"><span class="comment"># 更多CPU时间浪费到切换一，性能急剧下降，所以负载率不高</span></div><div class="line"><span class="comment"># Nginx基于事件的非阻塞多路复用(epoll或kquene)模型</span></div><div class="line"><span class="comment"># 一个进程在短时间内可以响应大量的请求</span></div><div class="line"><span class="comment"># 建议值 &lt;= cpu核心数量，一般高于cpu数量不会带好处，也许还有进程切换开销的负面影响</span></div><div class="line">worker_processes 4;</div><div class="line"></div><div class="line"><span class="comment"># 将work process绑定到特定cpu上（核心数量与数字位数对应，进程数量与数字的组数对应），避免进程在cpu间切换的开销</span></div><div class="line">worker_cpu_affinity 0001 0010 0100 1000 </div><div class="line"><span class="comment"># 8内核4进程时的设置方法 worker_cpu_affinity 00000001 00000010 00000100 10000000</span></div><div class="line"></div><div class="line"><span class="comment"># 每进程最大可打开文件描述符数量(linux上文件描述符比较广义，网络端口、设备、磁盘文件都是)</span></div><div class="line"><span class="comment"># 文件描述符用完了，新的连接会被拒绝，产生502类错误</span></div><div class="line"><span class="comment"># linux最大可打开文件数可通过ulimit -n FILECNT或 /etc/security/limits.conf配置</span></div><div class="line"><span class="comment"># 理论值 系统最大数量 / 进程数。但进程间工作量并不是平均分配的，所以可以设置的大一些</span></div><div class="line">worker_rlimit_nofile 655350 </div><div class="line"></div><div class="line"><span class="comment">#error_log  logs/error.log;</span></div><div class="line"><span class="comment">#error_log  logs/error.log  notice;</span></div><div class="line"><span class="comment">#error_log  logs/error.log  info;</span></div><div class="line"><span class="comment">#pid        logs/nginx.pid;</span></div><div class="line">events &#123;</div><div class="line">    <span class="comment"># 并发响应能力的关键配置值</span></div><div class="line">    <span class="comment"># 每个进程允许的最大同时连接数，work_connectins * worker_processes = maxConnection;</span></div><div class="line">    <span class="comment"># 要注意maxConnections不等同于可响应的用户数量，</span></div><div class="line">    <span class="comment"># 因为一般一个浏览器会同时开两条连接，如果反向代理，nginx到后端服务器的连接也要占用连接数</span></div><div class="line">    <span class="comment"># 所以，做静态服务器时，一般 maxClient = work_connectins * worker_processes / 2</span></div><div class="line">    <span class="comment"># 做反向代理服务器时 maxClient = work_connectins * worker_processes / 4</span></div><div class="line">    <span class="comment"># 这个值理论上越大越好，但最多可承受多少请求与配件和网络相关,也可最大可打开文件，最大可用sockets数量（约64K）有关</span></div><div class="line">    worker_connections  500;</div><div class="line">	</div><div class="line">    <span class="comment"># 指明使用epoll 或 kquene (*BSD)</span></div><div class="line">    use epoll</div><div class="line">    <span class="comment"># 备注：要达到超高负载下最好的网络响应能力，还有必要优化与网络相关的linux内核参数</span></div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_<span class="built_in">type</span>  application/octet-stream;</div><div class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></div><div class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></div><div class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></div><div class="line">    <span class="comment"># 关闭此项可减少IO开销，但也无法记录访问信息，不利用业务分析，一般运维情况不建议使用</span></div><div class="line">    access_<span class="built_in">log</span> off</div><div class="line">	</div><div class="line">    <span class="comment"># 只记录更为严重的错误日志，可减少IO压力</span></div><div class="line">    error_<span class="built_in">log</span> logs/error.log crit;</div><div class="line">    <span class="comment">#access_log  logs/access.log  main;</span></div><div class="line">	</div><div class="line">    <span class="comment"># 启用内核复制模式，应该保持开启达到最快IO效率</span></div><div class="line">    sendfile        on;</div><div class="line">	</div><div class="line">    <span class="comment"># 简单说，启动如下两项配置，会在数据包达到一定大小后再发送数据</span></div><div class="line">    <span class="comment"># 这样会减少网络通信次数，降低阻塞概率，但也会影响响应及时性</span></div><div class="line">    <span class="comment"># 比较适合于文件下载这类的大数据包通信场景</span></div><div class="line">    <span class="comment">#tcp_nopush     on; 在 </span></div><div class="line">    <span class="comment">#tcp_nodelay on|off on禁用Nagle算法 </span></div><div class="line">	</div><div class="line">    <span class="comment">#keepalive_timeout  0;</span></div><div class="line">    <span class="comment"># HTTP1.1支持持久连接alive</span></div><div class="line">    <span class="comment"># 降低每个连接的alive时间可在一定程度上提高可响应连接数量，所以一般可适当降低此值</span></div><div class="line">    keepalive_timeout  30s;</div><div class="line">	</div><div class="line">	<span class="comment">#隐藏nginx版本号</span></div><div class="line">	server_tokens off;</div><div class="line">	</div><div class="line">    <span class="comment"># 启动内容压缩，有效降低网络流量</span></div><div class="line">    gzip on;    </div><div class="line">	</div><div class="line">    <span class="comment"># 过短的内容压缩效果不佳，压缩过程还会浪费系统资源</span></div><div class="line">    gzip_min_length 1000;</div><div class="line">	</div><div class="line">    <span class="comment"># 可选值1~9,压缩级别越高压缩率越高，但对系统性能要求越高</span></div><div class="line">    gzip_comp_level 4;</div><div class="line">	</div><div class="line">    <span class="comment"># 压缩的内容类别</span></div><div class="line">    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</div><div class="line">    </div><div class="line">	<span class="comment"># 静态文件缓存</span></div><div class="line">    <span class="comment"># 最大缓存数量，文件未使用存活期</span></div><div class="line">    open_file_cache max=655350 inactive=20s;</div><div class="line">	</div><div class="line">    <span class="comment"># 验证缓存有效期时间间隔</span></div><div class="line">    open_file_cache_valid 30s;</div><div class="line">	</div><div class="line">    <span class="comment"># 有效期内文件最少使用次数</span></div><div class="line">    open_file_cache_min_uses 2;</div><div class="line">	</div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line">        <span class="comment">#charset koi8-r;</span></div><div class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></div><div class="line">        location / &#123;</div><div class="line">            root   html;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">#error_page  404              /404.html;</span></div><div class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></div><div class="line">        <span class="comment">#</span></div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></div><div class="line">        <span class="comment">#</span></div><div class="line">        <span class="comment">#location ~ \.php$ &#123;</span></div><div class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></div><div class="line">        <span class="comment">#&#125;</span></div><div class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></div><div class="line">        <span class="comment">#</span></div><div class="line">        <span class="comment">#location ~ \.php$ &#123;</span></div><div class="line">        <span class="comment">#    root           html;</span></div><div class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></div><div class="line">        <span class="comment">#    fastcgi_index  index.php;</span></div><div class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></div><div class="line">        <span class="comment">#    include        fastcgi_params;</span></div><div class="line">        <span class="comment">#&#125;</span></div><div class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></div><div class="line">        <span class="comment"># concurs with nginx's one</span></div><div class="line">        <span class="comment">#</span></div><div class="line">        <span class="comment">#location ~ /\.ht &#123;</span></div><div class="line">        <span class="comment">#    deny  all;</span></div><div class="line">        <span class="comment">#&#125;</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment">#server &#123;</span></div><div class="line">    <span class="comment">#    listen       8000;</span></div><div class="line">    <span class="comment">#    listen       somename:8080;</span></div><div class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></div><div class="line">    <span class="comment">#    location / &#123;</span></div><div class="line">    <span class="comment">#        root   html;</span></div><div class="line">    <span class="comment">#        index  index.html index.htm;</span></div><div class="line">    <span class="comment">#    &#125;</span></div><div class="line">    <span class="comment">#&#125;</span></div><div class="line">    <span class="comment"># HTTPS server</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment">#server &#123;</span></div><div class="line">    <span class="comment">#    listen       443 ssl;</span></div><div class="line">    <span class="comment">#    server_name  localhost;</span></div><div class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></div><div class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></div><div class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></div><div class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></div><div class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></div><div class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></div><div class="line">    <span class="comment">#    location / &#123;</span></div><div class="line">    <span class="comment">#        root   html;</span></div><div class="line">    <span class="comment">#        index  index.html index.htm;</span></div><div class="line">    <span class="comment">#    &#125;</span></div><div class="line">    <span class="comment">#&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h2>nginx的常用模块</h2><p></p>
<p></p><h3>ngx_http_stub_status_module模块</h3><br>此模块用来显示nginx访问的一些重要信息<br>基本配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location /nginx_status &#123;</div><div class="line">stub_status on;</div><div class="line">access_<span class="built_in">log</span>   off;</div><div class="line">allow SOME.IP.ADD.RESS;</div><div class="line">deny all;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>重启nginx之后直接在网页输入<a href="http://IP/nginx_status" target="_blank" rel="external">http://IP/nginx_status</a> 即可<br>返回结果类似于：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Active connections: 1 </div><div class="line">server accepts handled requests</div><div class="line">155 155 298 </div><div class="line">Reading: 0 Writing: 1 Waiting: 0</div></pre></td></tr></table></figure></p>
<p>Active connections:  处于活动状态的客户端连接的数量；<br>accepts：已经接受的客户端连接的总数；<br>handled：已经处理完成的客户端请求的总数；<br>requests：客户端发来的总的请求数；<br>Reading：处于读取客户端请求报文首部的连接数；<br>Writing：处于向客户端发送响应报文过程中的连接数；<br>Waiting：处于等待客户端发出请求的空闲连接数；</p>
<p></p><h3>ngx_http_gzip_module模块</h3><br>此模块用来压缩页面资源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">gzip on|off;</div><div class="line"><span class="comment">#启用或禁用压缩gzip响应报文</span></div><div class="line"></div><div class="line">gzip_comp_level level;</div><div class="line"><span class="comment">#指定压缩比（1-&gt;9），默认为1</span></div><div class="line"></div><div class="line">gzip_<span class="built_in">disable</span> regex...;</div><div class="line"><span class="comment">#regex是匹配客户端浏览器类型的模式，表示对所有匹配到的浏览器不执行压缩</span></div><div class="line"></div><div class="line">gzip_min_length length;</div><div class="line"><span class="comment">#触发启用压缩功能的响应报文的最小长度（启用压缩的下限）</span></div><div class="line"></div><div class="line">gzip_http_version 1.0|1.1 ;</div><div class="line"><span class="comment">#设定启用压缩响应功能时，协议的最小版本</span></div><div class="line"></div><div class="line">gzip_types mime-type;</div><div class="line"><span class="comment">#指定仅执行压缩的资源内容类型，默认为text/html;</span></div><div class="line"></div><div class="line">gzip proxied off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|ant...;</div><div class="line"><span class="comment">#对代理的请求基于何种属性判断其是否应该启用压缩功能</span></div></pre></td></tr></table></figure><p></p>
<p>配置示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_http_version 1.0;</div><div class="line">gzip_comp_level 6;</div><div class="line">gzip_<span class="built_in">disable</span> msie6;</div><div class="line">gzip_min_length 2;</div><div class="line">gzip_types text/plain text/css text/xml application/x-javascript  application/xml  application/json application/java-script;</div></pre></td></tr></table></figure></p>
<p></p><h3>ngx_http_ssl_module模块</h3><br>此模块主要用来配置https<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">ssl on|off； </div><div class="line"><span class="comment">#是否启用ssl应用</span></div><div class="line"></div><div class="line">ssl_certificate file;  </div><div class="line"><span class="comment">#当前虚拟主机使用的PEM格式的证书文件</span></div><div class="line"></div><div class="line">ssk_certificate_key file;   </div><div class="line"><span class="comment">#当前虚拟主机使用证书文件的私钥文件</span></div><div class="line"></div><div class="line">ssl_protocols [SSLv3][TLSv1][TLSv1.1][TLSv1.2]</div><div class="line"><span class="comment">#当前ssl的协议版本</span></div><div class="line"></div><div class="line">ssl_session_cache off|none|[<span class="built_in">builtin</span>[:size]][shared:name:size];</div><div class="line"><span class="comment">#指明ssl会话的缓存机制</span></div><div class="line">	off    坚决被禁止使用会话</div><div class="line">	none   有可能会禁止</div><div class="line">	<span class="built_in">builtin</span> 使用openssl内建的库缓存机制，此为各worker独有的</div><div class="line">		缺陷：同一个用户请求第一次可能会被调度到第一个worker，第二次可能会被调度到第二个worker，可能会导致缓存无法命中</div><div class="line">	shared  由各worker共享的缓存 </div><div class="line">	name	缓存空间的名称</div><div class="line">	size	字节为单位的缓存空间的大小，每1MB内存空间可缓存4000个会话</div><div class="line">ssl_clphers clphers;</div><div class="line"><span class="comment">#指明ssl的加密算法</span></div><div class="line"></div><div class="line">ssl_session_timeout time;</div><div class="line"><span class="comment">#ssl会话超时时长，至ssl session cache中缓存条目的超时时长</span></div></pre></td></tr></table></figure><p></p>
<p>配置示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 443;</div><div class="line">    ssl on;</div><div class="line">    ssl_certificate  /usr/<span class="built_in">local</span>/nginx/conf/server.crt;</div><div class="line">    ssl_certificate_key  /usr/<span class="built_in">local</span>/nginx/conf/server_nopwd.key;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h3>ngx_http_referer_module模块</h3><br>此模块用于屏蔽的网站请求无效值的字段,可以用来防盗链<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">valid_referers none | blocked | server_names | string ...;</div><div class="line"><span class="comment">#定义合法的referer数据；</span></div><div class="line">	none：请求报文首部没有refe rer首部；</div><div class="line">	blocked：请求报文的referer首部没有值；</div><div class="line">	server_names：其值是主机名；</div><div class="line">	arbitrary string：直接字符串，可以使用*作为通配符；</div><div class="line">	regular expression：被指定的正则表达式模式匹配到的字符串；要使用~起始；</div><div class="line">	</div><div class="line"><span class="variable">$invalid_referer</span>变量是由ngx_http_referer_module模块自动引入的</div><div class="line"><span class="comment">#只要不能被valid_referers none blocked...匹配到的，统统被归类到变量$invalid_referer中</span></div></pre></td></tr></table></figure><p></p>
<p>配置示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">valid_referers none blocked server_names *.magedu.com magedu.* ~\.magedu\.;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</div><div class="line">	<span class="built_in">return</span> 403;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h3>ngx_http_rewrite_module模块</h3><br>此模块主要用于url重写操作<br>last:重写完成后停止对当前uri在当前locatuion中的后续操作,改为对新uri的新一轮处理<br>break：重写完成后停止对当前uri在当前location中的后续其他重写操作<br>redirect: 重写完成后以永久重定向方式直接返回重写后生成的新URL给客户端，由客户对新URL进行请求（302）<br>permanent:重写完成后以永久重定向方式直接返回重写后生成的新URL给客户端，由客户对新URL进行请求（301）<br>配置示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~ MSIE) &#123;</div><div class="line">    rewrite ^(.*)$ /msie/<span class="variable">$1</span> <span class="built_in">break</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="variable">$http_cookie</span> ~* <span class="string">"id=([^;]+)(?:;|$)"</span>) &#123;</div><div class="line">    <span class="built_in">set</span> <span class="variable">$id</span> <span class="variable">$1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">if</span> (<span class="variable">$request_method</span> = POST) &#123;</div><div class="line">    <span class="built_in">return</span> 405;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">if</span> (<span class="variable">$slow</span>) &#123;</div><div class="line">    <span class="built_in">limit</span>_rate 10k;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</div><div class="line">    <span class="built_in">return</span> 403;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h3>ngx_http_fastcgi_module模块</h3><br>此模块主要用于基于fastcgi通信<p></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">fastcgi_connect_timeout 300;</div><div class="line"><span class="comment">#指定链接到后端FastCGI的超时时间。</span></div><div class="line"></div><div class="line">fastcgi_send_timeout 300;</div><div class="line"><span class="comment">#向FastCGI传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI传送请求的超时时间。</span></div><div class="line"></div><div class="line">fastcgi_<span class="built_in">read</span>_timeout 300;</div><div class="line"><span class="comment">#指定接收FastCGI应答的超时时间，这个值是指已经完成两次握手后接收FastCGI应答的超时时间。</span></div><div class="line"></div><div class="line">fastcgi_buffer_size 64k;</div><div class="line"><span class="comment">#指定读取FastCGI应答第一部分需要用多大的缓冲区，这个值表示将使用1个64KB的缓冲区读取应答的第一部分（应答头），可以设置为gastcgi_buffers选项指定的缓冲区大小。</span></div><div class="line"></div><div class="line">fastcgi_buffers 4 64k;</div><div class="line"><span class="comment">#指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答请求，如果一个php脚本所产生的页面大小为256KB，那么会分配4个64KB的缓冲区来缓存，如果页面大小大于256KB，那么大于256KB的部分会缓存到fastcgi_temp指定的路径中，但是这并不是好方法，因为内存中的数据处理速度要快于磁盘。一般这个值应该为站点中php脚本所产生的页面大小的中间值，如果站点大部分脚本所产生的页面大小为256KB，那么可以把这个值设置为“8 16K”、“4 64k”等。</span></div><div class="line"></div><div class="line">fastcgi_busy_buffers_size 128k;</div><div class="line"><span class="comment">#建议设置为fastcgi_buffer的两倍，繁忙时候的buffer</span></div><div class="line"></div><div class="line">fastcgi_temp_file_write_size 128k;</div><div class="line"><span class="comment">#在写入fastcgi_temp_path时将用多大的数据库，默认值是fastcgi_buffers的两倍，设置上述数值设置小时若负载上来时可能报502 Bad Gateway</span></div><div class="line"></div><div class="line">fastcgi_cache oldboy_ngnix;</div><div class="line"><span class="comment">#表示开启FastCGI缓存并为其指定一个名称。开启缓存非常有用，可以有效降低CPU的负载，并且防止502的错误放生，但是开启缓存也可能会引起其他问题，要很据具体情况选择</span></div><div class="line"></div><div class="line">fastcgi_cache_valid 200 302 1h;</div><div class="line"><span class="comment">#用来指定应答代码的缓存时间，实例中的值表示将2000和302应答缓存一小时，要和fastcgi_cache配合使用</span></div><div class="line"></div><div class="line">fastcgi_cache_valid 301 1d;</div><div class="line"><span class="comment">#将301应答缓存一天</span></div><div class="line"></div><div class="line">fastcgi_cache_valid any 1m;</div><div class="line"><span class="comment">#将其他应答缓存为1分钟</span></div><div class="line"></div><div class="line">fastcgi_cache_min_uses 1;</div><div class="line"><span class="comment">#请求的数量</span></div><div class="line"></div><div class="line">fastcgi_cache_path /data/ngx_fcgi_cache levels=2:2 keys_zone=ngx_fcgi_cache:512m;</div><div class="line"><span class="comment">#定义缓存的路径</span></div></pre></td></tr></table></figure>
<p>配置示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location ~ \.php$ &#123;</div><div class="line">	root           html;</div><div class="line">	fastcgi_pass   127.0.0.1:9000;</div><div class="line">	fastcgi_index  index.php;</div><div class="line">	fastcgi_param  SCRIPT_FILENAME  /www/html/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">	include        fastcgi_params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于其他的一些模块（例如ngx_http_proxy_module、ngx_http_upstream_module）还听下回分解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Nginx作为一个非常流行和成熟的Web Server和Reserve Proxy Server，网上有大量的性能优化教程，但是不同的业务场景千差万别，什么配置是最适合自己的，还是只有基于自己的业务才能配置出适合自己的参数。&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://chen-hao.com.cn/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="nginx" scheme="http://chen-hao.com.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux常见配置文件汇总</title>
    <link href="http://chen-hao.com.cn/Linux%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B1%87%E6%80%BB.html"/>
    <id>http://chen-hao.com.cn/Linux常见配置文件汇总.html</id>
    <published>2016-10-08T07:29:48.000Z</published>
    <updated>2016-10-08T09:34:03.137Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在我们的运维工作中，如果能够清楚的知道Linux系统中常用的配置文件是做什么的。那么对于我们使用和维护Linux系统都有极大帮助，本文主要介绍一些配置文件的作用和功能。<br> <a id="more"></a></p>
</blockquote>
<p></p><h2>FHS层级结构标准</h2><br><img src="/uploads/file.jpg" class="blockquote-center"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/bin：所有用户可用的基本命令程序文件；</div><div class="line">/sbin：实现管理功能的程序文件；</div><div class="line">/boot：引导加载器的静态文件；内核、ramdisk（initrd，initramfs）文件也在此处；可独立分区；</div><div class="line">/dev：存储特殊文件或设备文件；</div><div class="line">	设备有两种类型；</div><div class="line">		块设备：支持随机访问，以“块”为单位实现数据交换；文件类型标识符为“b”；</div><div class="line">		字符设备：是线性访问，以“字符”为单位，按顺序实现数据交换；文件类型标识符为“c”；</div><div class="line">/etc：系统和应用程序配置文件的存放位置；</div><div class="line">/home：普通用户的家目录；可独立分区；</div><div class="line">	/home/USERNAME：每个都有自己专用的家目录；</div><div class="line">/root：管理员的家目录；</div><div class="line">/lib：存放共享库文件，以及内核模块文件；</div><div class="line">	modules：内核模块；</div><div class="line">/lib64:64位系统特有的存放位置；</div><div class="line">/media：挂载便携性设备；</div><div class="line">/mnt：挂载临时文件系统；如硬盘，或硬盘分区；</div><div class="line">/opt：第三方应用程序的安装路径；</div><div class="line">/srv：存放当前系统提供的服务运行中用到的中间数据；</div><div class="line">/tmp：临时文件存放位置；</div><div class="line">/usr：可独立分区；</div><div class="line">	/usr Hierarchy是一个层级结构，存放全局共享（普通用户）只读数据；</div><div class="line">	文件系统第二重要分区，可在各遵循FHS发行版之间共享；</div><div class="line">	/usr目录下必须有的目录：</div><div class="line">		/bin，/sbin；</div><div class="line">		/lib；</div><div class="line">		/include：存放c程序的头文件（开发C程序或手动编译时用到）；</div><div class="line">		/share：平台的独立的共享数据文件；</div><div class="line">		/<span class="built_in">local</span>：是另一个层级目录，可独立分区；第三方应用程序安装路径；</div><div class="line">	/usr目录下的特别可选目录：</div><div class="line">		/X11R6：X Window System，版本为11，发行号为6；</div><div class="line">		/game</div><div class="line">		/lib64：库文件；</div><div class="line">		/src：程序源代码（安装后放在bin，sbin目录下）；</div><div class="line">	/usr/<span class="built_in">local</span>：是另一个层级结构目录（必须有相关目录），第三方应用程序安装路径；可使用独分区；</div><div class="line">		/bin，/sbin；</div><div class="line">		/lib；</div><div class="line">/var：可变状态信息数据；</div><div class="line">也是一个层级结构Hierarchy（必须有相关目录），可变数据存放位置；可独立分区；</div><div class="line">	/var目录下必须有的目录：</div><div class="line">		/cache：应用程序的缓存数据；</div><div class="line">		/lib：存放变化的状态信息；</div><div class="line">		/<span class="built_in">local</span>：存放/usr/<span class="built_in">local</span>下的应用程序可变的信息；</div><div class="line">		/lock：锁文件；</div><div class="line">		/<span class="built_in">log</span>：日志文件目录；</div><div class="line">		/opt：存放/opt目录下运行程序的可变状态信息数据；</div><div class="line">		/run：存放运行进程相关的数据，主要用于存储pid文件；</div><div class="line">		/spool：</div><div class="line">		/tmp：存放系统重启后能保留的文件；</div><div class="line">/proc：基于内存的虚拟（伪）文件系统，用于为内核及进程存储相关信息；它们多数为内核参数，例如：net.ipv4.ip_forward,虚拟为/proc/sys/net/ipv4/ip_forward；关机后内容为空；</div><div class="line">/sys：sysfs虚拟文件系统，是一种提供了比/proc更为理想的访问内核数据的另一个途径；其主要作用在于为管理Linux系统上的设备提供一种统一模型的接口；</div></pre></td></tr></table></figure><p></p>
<p></p><h2>文件的特征</h2><p></p>
<p></p><h3>不同颜色的文件类型</h3><p></p>
<ul>
<li>蓝色文件 +++++++++++++++++++++ 目录</li>
<li>白色文件 +++++++++++++++++++++ 普通文件</li>
<li>绿色文件 +++++++++++++++++++++ 可执行文件，可执行的程序</li>
<li>红色文件 +++++++++++++++++++++ 压缩文件或者包文件</li>
<li>黄色文件 +++++++++++++++++++++ 设备文件（dev目录下）</li>
<li>青绿色文件 +++++++++++++++++++ 可执行文件</li>
<li>青蓝色文件 +++++++++++++++++++ 链接文件，主要是使用ln命令建立的文件</li>
<li>粉红色文件 +++++++++++++++++++ 图片文件或者是socket文件</li>
<li>青黄色文件 +++++++++++++++++++ 管道文件</li>
</ul>
<p></p><h3>不同字符的文件类型</h3><p></p>
<ul>
<li>-：普通文件</li>
<li>d：目录文件</li>
<li>l：链接文件</li>
<li>b：块设备文件</li>
<li>c：字符设备文件</li>
<li>p：管道文件</li>
</ul>
<p></p><h2>/etc 配置文件</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/etc/passwd			用户数据库，其中的域给出了用户名、真实姓名、家目录、加密口令和用户的其他信息</div><div class="line">/etc/group			类似/etc/passwd,但对应的是组</div><div class="line">/etc/inittab		init 的配置文件（初始化配置）</div><div class="line">/etc/issue			在登录提示符前的输出信息（通常包括系统的一段短说明或欢迎信息）</div><div class="line">/etc/motd			成功登录后自动输出（经常用于通告信息，如计划关时间的警告）</div><div class="line">/etc/mtab			当前安装的文件系统列表。由scripts初始化，并由mount命令自动更新。需要一个当前安装的文件系统的列表时使用，例如df 命令，当df –a 时，查看到的信息应和其一致</div><div class="line">/etc/shadow			在安装了影子口令软件的系统上的影子口令文件，影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中</div><div class="line">/etc/securetty		确认安全终端，即哪个终端允许root 登录</div><div class="line">/etc/shells			列出可信任的shell（chsh 命令允许用户在本文件指定范围内改变登录shell）</div><div class="line">/etc/profile		用户登录时都会运行的环境变量</div><div class="line">/etc/hosts			更改主机名和IP 地址的对应关系</div><div class="line">/etc/bashrc			命令的别名</div><div class="line">/etc/yum.repos.d	配置本地YUM源</div><div class="line">/etc/fstab			系统启动时自动加载的设备，（用于配置自动挂载设备）</div><div class="line">/etc/resolv.conf	配置DNS 地址</div><div class="line">/etc/rc.d/init.d	用于放置几乎所有服务的启动脚本</div><div class="line">/etc/sysctl.conf	内核参数配置文件</div><div class="line">/etc/crontab		系统定义的任务计划</div><div class="line">/etc/anacrontab		实现检查过期和未完成的crontab的任务的配置文件</div><div class="line">/etc/xinetd.con		xinetd 的主配置文件</div><div class="line">/etc/hosts.allow	TCP的一个许可表</div><div class="line">/etc/host.deny		TCP的一个拒绝表</div><div class="line">/etc/udev/rules.d	系统初始化时将硬件探测信息输出成设备配置文件</div><div class="line">/etc/rc.d/rc.sysinit		系统启动设置配置文件</div><div class="line">/etc/sysconfig/i18n*		设置系统语言和字符类型</div><div class="line">/etc/sysconfig/network		更改hostname（主机名）以及网卡工作状态</div><div class="line">/etc/sysconfig/iptables		防火墙主配置文件</div><div class="line">/etc/sysconfig/network-scripts/ifcfg-eth0		配置网卡eth0</div></pre></td></tr></table></figure><p></p>
<p></p><h3>注</h3><p></p>
<blockquote>
<p>/etc/passwd                存放用户的账号</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slaceware:x:5000:5000:Test User:/home/slackware:/bin/bash</div><div class="line">Name：passwd位置：UID：GID:CECOS(注释):diectory（家目录）:shell</div></pre></td></tr></table></figure>
<blockquote>
<p>/etc/shadow                存放用户的密码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slaceware:<span class="variable">$1</span><span class="variable">$12345678</span><span class="variable">$0ME5N6oDyoEAwUp7b5UDM</span>/:15355:0:99999:7::: </div><div class="line">Name:加密后的密码：时间1：时间2：时间3：时间4：时间5：时间6：预留段</div></pre></td></tr></table></figure>
<p>加密后的密码：以$分开，第一个$后是1，说明加密算法是md5，第二个$后是加的sail，第三个$后是加的密码<br>时间1：从1970年1月1日起到最近的修改的天数<br>时间2：密码的最短使用期限<br>时间3：密码最长使用期限<br>时间4：在密码过期之前多少天开始警告<br>时间5：在密码过期多少天用户禁用<br>时间6：自1970年1月1日起多长时间用户被禁用</p>
<blockquote>
<p>交互式登陆的用户：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/profile --&gt;/etc/profile.d/* --&gt;~/.bash_profile --&gt;~/.bashrc --&gt;/etc/bashrc</div></pre></td></tr></table></figure>
<blockquote>
<p>非交互式登录：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.bashrc --&gt;/etc/bashrc --&gt;.etc/profile.d/*</div></pre></td></tr></table></figure>
<p></p><h2>/proc 配置文件</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/proc/dma         		显示当前使用的DMA 通道</div><div class="line">/proc/filesystems 		核心配置的文件系统</div><div class="line">/proc/interrupts 	 	显示使用的中</div><div class="line">/proc/ioports			当前使用的I/O 端口</div><div class="line">/proc/kcore				系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存 (记住：除非你把它拷贝到什么地方，/proc 下没有任何东西占用任何磁盘空间。）</div><div class="line">/proc/kmsg				核心输出的消息。也被送到syslog</div><div class="line">/proc/ksyms				核心符号表</div><div class="line">/proc/loadavg			系统<span class="string">"平均负载"</span>；3 个指示器指出系统当前的工作量</div><div class="line">/proc/meminfo			存储器使用信息，包括物理内存和swap</div><div class="line">/proc/modules			当前加载了哪些核心模块</div><div class="line">/proc/net				网络协议状态信息</div><div class="line">/proc/self				到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc</div><div class="line">时，是不同的连接   	  </div><div class="line">/proc/<span class="built_in">stat</span>				系统的不同状态</div><div class="line">/proc/uptime			系统启动的时间长度	   </div><div class="line">/proc/cpuinfo			处理器信息，如类型、制造商、型号和性能</div><div class="line">/proc/devices			当前运行的核心配置的设备驱动的列表</div><div class="line">/proc/version			核心版本</div><div class="line">/proc/mdstat			RAID设备的信息</div><div class="line">/proc/cmdline			grub信息</div><div class="line">/proc/cpuinfo			显示CPU的相关信息</div><div class="line">/proc/cpuset			cpu集合 用于显示当前进程可以应用到哪些cpu上</div><div class="line">/proc/filesystem		当前系统支持的文件系统种类</div><div class="line">/etc/245/vm     		系统进程ID号为245的进程的虚拟内存信息</div><div class="line">/etc/245/kernel 		系统进程ID号为245的进程的内核信息</div><div class="line">/proc/mounts    		挂载的所有文件系统</div><div class="line">/proc/swaps     		交换分区信息   </div><div class="line">/proc/uptime    		启动系统运行时长</div><div class="line">/proc/sys				(具有写权限)定义内核参数的值来定义内核的功能</div><div class="line">/proc/sys/kernel/hostname  		主机名的设定</div></pre></td></tr></table></figure><p></p>
<p></p><h2>/usr配置文件</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/usr/bin				普通的应用程序</div><div class="line">/usr/doc				linux 文档</div><div class="line">/usr/include			linux 下C 开发和编译应用程序所需要的头文件</div><div class="line">/usr/include/g++		C++编译器的头文</div><div class="line">/usr/lib				常用的动态链接库和软件包的配置文件</div><div class="line">/usr/src				系统软件的源代码</div><div class="line">/usr/src/linux linux	内核的源代码</div><div class="line">/usr/<span class="built_in">local</span>/bin			本地增加的命令</div><div class="line">/usr/<span class="built_in">local</span>/lib			本地增加的库</div><div class="line">/usr/sbin				为系统管理员保留的程序</div><div class="line">/usr/share/fonts		字体文件</div><div class="line">/usr/share/doc			各种文档文件</div><div class="line">/usr/share/man			系统手册页</div><div class="line">/usr/<span class="built_in">local</span>/apache/man	定义man目录文集</div></pre></td></tr></table></figure><p></p>
<p></p><h2>其它目录配置文件</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/dev/null                  没有用的文件所放的位置，相当于回收站，吞噬设备</div><div class="line">/dev/zero                  初始化磁盘（吐零）  </div><div class="line">/dev/random                随机数生成器，熵池</div><div class="line">/dev/urandom               伪随机数生成器，熵池。（当熵池耗尽时，用软件生成随机数）</div><div class="line">/var/spool/mail/root       定义mail设置发送用户为root</div><div class="line">/bin/bash                  系统内置脚本</div><div class="line">/home/USERNAME             用户配额文件</div><div class="line">/var/spool/cron/USERNAME   用户定义的任务计划</div><div class="line">/sbin/nologin			   不能登陆的用户</div><div class="line">/var/<span class="built_in">log</span>/message           系统的日志文件</div></pre></td></tr></table></figure><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们的运维工作中，如果能够清楚的知道Linux系统中常用的配置文件是做什么的。那么对于我们使用和维护Linux系统都有极大帮助，本文主要介绍一些配置文件的作用和功能。&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="http://chen-hao.com.cn/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="文件系统" scheme="http://chen-hao.com.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux数据恢复</title>
    <link href="http://chen-hao.com.cn/Linux%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D.html"/>
    <id>http://chen-hao.com.cn/Linux数据恢复.html</id>
    <published>2016-09-22T08:55:42.000Z</published>
    <updated>2016-09-23T02:47:30.619Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对于一名运维人员来说，保证数据的安全是根本职责。所以在维护系统的时候，要慎之又慎，但是有时难免会出现数据被误删除的情况，在这个时候改如何快速、有效地恢复数据呢？本文就主要介绍一款Linux恢复数据的神器。<br> <a id="more"></a></p>
</blockquote>
<h2>extundelete恢复原理</h2><br><strong>extundelete</strong>恢复文件时并不依赖特定文件格式，首先extundelete会通过文件系统的inode信息（根目录的inode一般为2）来获得当前文件系统下所有文件的信息，包括存在的和已经删除的文件，这些信息包括文件名和inode。然后利用inode信息结合日志去查询该inode所在的block位置，包括直接块，间接块等信息。最后利用dd命令将这些信息备份出来，从而恢复数据文件。<br><br><h2>extundelete安装</h2>

<p>extundelete的<a href="https://sourceforge.net/projects/extundelete/files/latest/download" target="_blank" rel="external">官方下载地址</a>，目前的稳定版本是extundelete-0.2.4。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yum -y install e2fsprogs.x86_64 e2fsprogs-devel.x86_64 e2fsprogs-libs.x86_64  <span class="comment"># 安装依赖包</span></div><div class="line">tar -jxvf extundelete-0.2.4.tar.bz2 </div><div class="line"><span class="built_in">cd</span> extundelete-0.2.4 </div><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/extundelete </div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure></p>
<p>成功安装extundelete后，会在系统中生成一个extundelete可执行文件。可以通过“extundelete  –help”获得此软件的使用方法。</p>
<p></p><h2>extundelete命令详解</h2><br><strong>extundelete [options] [action] device-file</strong><p></p>
<ul>
<li><p><strong>options</strong>：<br>–version, -[vV]，显示软件版本号。<br>–help，显示软件帮助信息。<br>–superblock，显示超级块信息。<br>–journal，显示日志信息。<br>–after dtime，时间参数，表示在某段时间之后被删的文件或目录。<br>–before dtime，时间参数，表示在某段时间之前被删的文件或目录。</p>
</li>
<li><p><strong>action</strong>：<br>–inode ino，显示节点“ino”的信息。<br>–block blk，显示数据块“blk”的信息。<br>–restore-inode ino[,ino,…]，恢复命令参数，表示恢复节点“ino”的文件，恢复的文件会自动放在当前目录下的RESTORED_FILES文件夹中，使用节点编号作为扩展名。<br>–restore-file ‘path’，恢复命令参数，表示将恢复指定路径的文件，并把恢复的文件放在当前目录下的RECOVERED_FILES目录中。<br>–restore-files ‘path’，恢复命令参数，表示将恢复在路径中已列出的所有文件。<br>–restore-all，恢复命令参数，表示将尝试恢复所有目录和文件。<br>-j journal，表示从已经命名的文件中读取扩展日志。<br>-b blocknumber，表示使用之前备份的超级块来打开文件系统，一般用于查看现有超级块是不是当前所要的文件。<br>-B blocksize，表示使用数据块大小来打开文件系统，一般用于查看已经知道大小的文件。</p>
</li>
</ul>
<p></p><h2>恢复数据实战</h2><p></p>
<blockquote>
<p>这里特别提醒一下，当确定删除重要的数据了，这时候<strong>千万千万</strong>不要往这块磁盘上写数据。正确的操作应该是立马umount，然后以只读方式挂载（mount -o remount,ro /dev/test）到其他服务器或测试机。否则有可能会出现数据恢复不了的情景。</p>
</blockquote>
<p></p><h3>查看文件系统</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">df -hT</div><div class="line">文件系统    类型      容量  已用  可用 已用%% 挂载点</div><div class="line">/dev/mapper/vg_weiwang1-lv_root</div><div class="line">              ext4     50G   40G  7.2G  85% /</div><div class="line">tmpfs        tmpfs    5.3G     0  5.3G   0% /dev/shm</div><div class="line">/dev/vda1     ext4    485M   32M  428M   7% /boot</div><div class="line">/dev/mapper/vg_weiwang1-lv_home</div><div class="line">              ext4     44G  182M   42G   1% /home</div></pre></td></tr></table></figure><p></p>
<p>找到对应的文件系统和挂载点</p>
<p></p><h3>查看当前路径下的文件目录删除情况</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">extundelete --inode 2 /dev/vda1</div><div class="line">lost+found                                        11</div><div class="line">grub                                              65025</div><div class="line">efi                                               65027</div><div class="line">222                                               32513          Deleted</div><div class="line">.vmlinuz-2.6.32-358.el6.x86_64.hmac               12</div><div class="line">System.map-2.6.32-358.el6.x86_64                  13</div><div class="line">config-2.6.32-358.el6.x86_64                      14</div><div class="line">symvers-2.6.32-358.el6.x86_64.gz                  15</div><div class="line">vmlinuz-2.6.32-358.el6.x86_64                     16</div><div class="line">initramfs-2.6.32-358.el6.x86_64.img               17</div></pre></td></tr></table></figure><p></p>
<p></p><h3>恢复被删除文件</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extundelete  /dev/vda1  --restore-file 222          <span class="comment"># 恢复单个文件</span></div><div class="line">extundelete  /dev/vda1  --restore-directory grub    <span class="comment"># 恢复单个目录</span></div><div class="line">extundelete  /dev/vda1  --restore-all               <span class="comment"># 恢复所有被删除数据</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>补充</h2><br>在Linux系统下，通过命令“rm -rf”可以将任何数据直接从硬盘删除，并且没有任何提示，同时Linux下也没有与Windows下回收站类似的功能，也就意味着，数据在删除后通过常规的手段是无法恢复的，因此使用这个命令要非常慎重。其实有一个方法，那就是将要删除的东西通过mv命令移动到系统下的/tmp目录下，然后写个脚本定期执行清除操作，这样做可以在一定程度上降低误删除数据的危险性。<br>其实保证数据安全最好的方法是做好备份，虽然备份不是万能的，但是没有备份是万万不行的。任何数据恢复工具都有一定局限性，都不能保证完整地恢复出所有数据，因此，把备份作为核心，把数据恢复工具作为辅助是运维人员必须坚持的一个准则。<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于一名运维人员来说，保证数据的安全是根本职责。所以在维护系统的时候，要慎之又慎，但是有时难免会出现数据被误删除的情况，在这个时候改如何快速、有效地恢复数据呢？本文就主要介绍一款Linux恢复数据的神器。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://chen-hao.com.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="extundelete" scheme="http://chen-hao.com.cn/tags/extundelete/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手，四次断开</title>
    <link href="http://chen-hao.com.cn/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%96%AD%E5%BC%80.html"/>
    <id>http://chen-hao.com.cn/TCP三次握手，四次断开.html</id>
    <published>2016-09-22T02:41:26.000Z</published>
    <updated>2016-09-22T04:59:10.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前面试的过程中，总是因为一些基础知识而被PASS掉，同样万丈高楼平地起，任何高大上的东西都离不开基础知识。所以把基础打牢后面的知识学习起来应该会一日千里，这里废话不多说，开始进入主题。<br><a id="more"></a></p>
</blockquote>
<p></p><h2>OSI 七层网络模型</h2><p></p>
<blockquote>
<p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，ISO/IEC 7498-1），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。 — 维基百科</p>
</blockquote>
<p><img src="/uploads/OSI7model.png" class="blockquote-center"></p>
<ul>
<li><p><strong>第7层 应用层(Application Layer)</strong><br>提供为应用软件而设的界面，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</p>
</li>
<li><p><strong>第6层 表示层(Presentation Layer)</strong><br>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
</li>
<li><p><strong>第5层 会话层(Session Layer)</strong><br>负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</p>
</li>
<li><p><strong>第4层 传输层(Transport Layer)</strong><br>把传输表头(TH)加至数据以形成数据报。传输表头包含了所使用的协议等发送信息。例如:传输控制协议义(TCP) 等。</p>
</li>
<li><p><strong>第3层 网络层(Network Layer)</strong><br>决定数据的路径选择和转寄，它网络表头(NH)加至数据报，以形成分组。网络表头包含了网络数据。例如:互联网协议(IP) 等。</p>
</li>
<li><p><strong>第2层 数据链路层(Data Link Layer)</strong><br>负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成了帧。数据链表头(DLH)是包含了物理地址和错误侦测及改错的方法。数据链表尾(DLT)是一串指示数据包末端的字符串。例如以太网、无线局域网(Wi-Fi)和通用分组无线服务(GPRS)等。</p>
</li>
<li><p><strong>第1层 物理层(Physical Layer)</strong><br>在局部局域网络上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等</p>
</li>
</ul>
<p></p><h2>TCP/IP</h2><p></p>
<blockquote>
<p>TCP/IP是一个协议族，通常分不同层次进行开发，每个层次负责不同的通信功能。包含以下四个层次，与OSI7层关系如下：</p>
</blockquote>
<p><img src="/uploads/tcpip.png" class="blockquote-center"></p>
<ol>
<li><strong>网络接口层</strong>，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节，对应的网络协议主要是：Ethernet、FDDI和能传输IP数据包的任何协议。</li>
<li><strong>网际层</strong>，处理分组在网络中的活动，例如分组的选路。网络层协议包括IP协议（网际协议）、ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。</li>
<li><strong>传输层</strong>主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供高可靠性的数据通信。他所作的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端通信，因此应用层可以忽略所有这些细节。而另一方面，UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必须的可靠性必须由应用层来提供。</li>
<li><strong>应用层</strong>负责处理特定的应用程序细节。包括Telnet（远程登录）、FTP（文件传输协议）、SMTP（简单邮件传送协议）以及SNMP（简单网络管理协议）等。</li>
</ol>
<p></p><h3>TCP概念</h3><p></p>
<blockquote>
<p>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。</p>
</blockquote>
<p><strong>TCP的特点有：</strong></p>
<ol>
<li>TCP是面向连接的运输层协议</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li>
<li>TCP提供可靠交付的服务</li>
<li>TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</li>
<li>面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流</li>
</ol>
<p>TCP报文首部结构如下图：<br><img src="/uploads/tcpbao.png" class="blockquote-center"><br><strong>图解：</strong></p>
<ol>
<li>源端口号：数据发起者的端口号，16bit</li>
<li>目的端口号：数据接收者的端口号，16bit</li>
<li>序号：32bit的序列号，由发送方使用</li>
<li>确认序号：32bit的确认号，是接收数据方期望收到发送方的下一个报文段的序号，因此确认序号应当是上次已成功收到数据字节序号加1。</li>
<li>首部长度：首部中32bit字的数目，可表示15*32bit=60字节的首部。一般首部长度为20字节。</li>
<li>保留：6bit, 均为0</li>
<li>紧急URG：当URG=1时，表示报文段中有紧急数据，应尽快传送。</li>
<li>确认比特 ACK：ACK = 1时代表这是一个确认的TCP包，取值0则不是确认包。</li>
<li>推送比特 PSH：当发送端PSH=1时，接收端尽快的交付给应用进程。</li>
<li>复位比特（RST）：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接。</li>
<li>同步比特 SYN：在建立连接是用来同步序号。SYN=1， ACK=0表示一个连接请求报文段。SYN=1，ACK=1表示同意建立连接。</li>
<li>终止比特 FIN：FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li>
<li>窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。</li>
<li>检验和：该字段检验的范围包括首部和数据这两部分。由发端计算和存储，并由收端进行验证。</li>
<li>紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。</li>
<li>选项：长度可变，最长可达40字节</li>
</ol>
<p></p><h3>三次握手建立连接</h3><br><img src="/uploads/tcp3.png" class="blockquote-center"><p></p>
<ul>
<li><p><strong>第一次握手</strong>：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
</li>
<li><p><strong>第二次握手</strong>：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
</li>
<li><p><strong>第三次握手</strong>：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据.</p>
<p></p><h3>四次挥手断开连接</h3><br><img src="/uploads/tcp4.png" class="blockquote-center"><p></p>
<p><strong>注意</strong>： 中断连接端可以是Client端，也可以是Server端。<br>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了“，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息“。这个时候Client端就进入<strong>FIN_WAIT</strong>状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了“。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p></p><h4>client经历过程</h4><br><img src="/uploads/client.png" class="blockquote-center"><p></p>
<p></p><h4>server经历过程</h4><br><img src="/uploads/server.png" class="blockquote-center"><br><strong>注意</strong> 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。<p></p>
<p></p><h3>问题</h3><br> -【<strong>问题1</strong>】为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。<p></p>
<p> -【<strong>问题2</strong>】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<p></p><h3>完整过程图</h3><br><img src="/uploads/wanz.png" class="blockquote-center"><p></p>
<p></p><h3>TCP连接状态码</h3><p></p>
<ul>
<li><p><strong>LISTEN</strong>：侦听来自远方的TCP端口的连接请求</p>
</li>
<li><p><strong>SYN-SENT</strong>：再发送连接请求后等待匹配的连接请求</p>
</li>
<li><p><strong>SYN-RECEIVED</strong>：再收到和发送一个连接请求后等待对方对连接请求的确认</p>
</li>
<li><p><strong>ESTABLISHED</strong>：代表一个打开的连接</p>
</li>
<li><p><strong>FIN-WAIT-1</strong>：等待远程TCP连接中断请求，或先前的连接中断请求的确认</p>
</li>
<li><p><strong>FIN-WAIT-2</strong>：从远程TCP等待连接中断请求</p>
</li>
<li><p><strong>CLOSE-WAIT</strong>：等待从本地用户发来的连接中断请求</p>
</li>
<li><p><strong>CLOSING</strong>：等待远程TCP对连接中断的确认</p>
</li>
<li><p><strong>LAST-ACK</strong>：等待原来的发向远程TCP的连接中断请求的确认</p>
</li>
<li><p><strong>TIME-WAIT</strong>：等待足够的时间以确保远程TCP接收到连接中断请求的确认</p>
</li>
<li><p><strong>CLOSED</strong>：没有任何连接状态</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前面试的过程中，总是因为一些基础知识而被PASS掉，同样万丈高楼平地起，任何高大上的东西都离不开基础知识。所以把基础打牢后面的知识学习起来应该会一日千里，这里废话不多说，开始进入主题。&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="http://chen-hao.com.cn/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="TCP/IP" scheme="http://chen-hao.com.cn/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统空间被占满却找不到大文件</title>
    <link href="http://chen-hao.com.cn/Linux%E7%B3%BB%E7%BB%9F%E7%A9%BA%E9%97%B4%E8%A2%AB%E5%8D%A0%E6%BB%A1%E5%8D%B4%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6.html"/>
    <id>http://chen-hao.com.cn/Linux系统空间被占满却找不到大文件.html</id>
    <published>2016-09-21T08:13:29.000Z</published>
    <updated>2016-11-14T09:17:19.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近遇到服务器上的日志文件太大导致磁盘满了，但是这个时候我找到并删除了，过了一段时间空间又被占满，这个时候再找大文件却找不到了。<br><a id="more"></a></p>
</blockquote>
<p></p><h2>故障现象</h2><br>服务器磁盘爆满<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">df -hT</div><div class="line">文件系统    类型      容量  已用  可用 已用%% 挂载点</div><div class="line">/dev/mapper/vg_weiwang1-lv_root</div><div class="line">              ext4     50G   50G  0    100% /</div><div class="line">tmpfs        tmpfs    5.3G     0  5.3G   0% /dev/shm</div><div class="line">/dev/vda1     ext4    485M   32M  428M   7% /boot</div><div class="line">/dev/mapper/vg_weiwang1-lv_home</div><div class="line">              ext4     44G  44G   0    100% /home</div></pre></td></tr></table></figure><p></p>
<p></p><h2>处理思路</h2><br>使用find 查找到大文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find / -size +1G | xargs ls -lh</div></pre></td></tr></table></figure><p></p>
<p>确定好数据无用之后删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find / -size +1G | xargs rm -rf</div></pre></td></tr></table></figure></p>
<p>这时候在使用df命令确认一次，发现磁盘空间可以用了。将近过了一个小时，用ftp上传到这台服务器上传失败，再df看看。磁盘居然又满了，但是实际用到的空间才10G不到。<br>以为是服务器中病毒了，ps -ef 查看有没有什么异常的进程，最后万般排查均没有发现问题。无奈之下只好使用网管大招–重启来试试看，重启完成之后，服务器磁盘空间恢复正常了。</p>
<p></p><h2>理论知识</h2><br>在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink)。如果文件是被打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用<p></p>
<p></p><h3>解决方法</h3><br>使用 lsof 找到被删除但是fd没释放的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof | grep deleted</div></pre></td></tr></table></figure><p></p>
<p>找到占用删除文件的进程列表了, 然后杀死( kill -9 )对应的进程或者重启对应的服务即可。不过这次正好歪打正着重启解决问题了，还是不推荐重启解决此类问题。<br>以后如果遇到磁盘空间占满，切勿直接删除文件，可以通过在线清空的方式解决此类问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; /var/<span class="built_in">log</span>/httpd/acess.log</div></pre></td></tr></table></figure></p>
<p>通过这种方法，磁盘空间不但可以马上释放，也可保障进程继续向文件写入日志，这种方法经常用于在线清理各种服务所产生的日志文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近遇到服务器上的日志文件太大导致磁盘满了，但是这个时候我找到并删除了，过了一段时间空间又被占满，这个时候再找大文件却找不到了。&lt;br&gt;
    
    </summary>
    
      <category term="故障处理" scheme="http://chen-hao.com.cn/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
      <category term="故障" scheme="http://chen-hao.com.cn/tags/%E6%95%85%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>获取系统信息命令汇总</title>
    <link href="http://chen-hao.com.cn/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB.html"/>
    <id>http://chen-hao.com.cn/获取系统信息命令汇总.html</id>
    <published>2016-09-20T06:02:14.000Z</published>
    <updated>2016-10-08T09:40:00.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这里仅仅只是记录一些常用的获取系统信息的命令，其他更多命令请参考官方文档。</p>
</blockquote>
<a id="more"></a>
<p></p><h2>系统</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">uname <span class="_">-a</span>                <span class="comment"># 查看内核/操作系统/CPU信息</span></div><div class="line">head -n 1 /etc/issue    <span class="comment"># 查看操作系统版本</span></div><div class="line">cat /proc/cpuinfo       <span class="comment"># 查看CPU信息</span></div><div class="line">hostname                <span class="comment"># 查看计算机名</span></div><div class="line">lspci -tv               <span class="comment"># 列出所有PCI设备</span></div><div class="line">lsusb -tv               <span class="comment"># 列出所有USB设备</span></div><div class="line">lsmod                   <span class="comment"># 列出加载的内核模块</span></div><div class="line">env 或 <span class="built_in">set</span>              <span class="comment"># 查看环境变量</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>资源</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">free -m                 <span class="comment"># 查看内存使用量和交换区使用量</span></div><div class="line">df -h                   <span class="comment"># 查看各分区使用情况</span></div><div class="line">du -sh &lt;目录名&gt;         <span class="comment"># 查看指定目录的大小</span></div><div class="line">grep MemTotal /proc/meminfo   <span class="comment"># 查看内存总量</span></div><div class="line">grep MemFree /proc/meminfo    <span class="comment"># 查看空闲内存量</span></div><div class="line">uptime                  <span class="comment"># 查看系统运行时间、用户数、负载</span></div><div class="line">cat /proc/loadavg       <span class="comment"># 查看系统负载</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>磁盘和分区</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mount | column -t       <span class="comment"># 查看挂接的分区状态</span></div><div class="line">fdisk <span class="_">-l</span>                <span class="comment"># 查看所有分区</span></div><div class="line">swapon <span class="_">-s</span>               <span class="comment"># 查看所有交换分区</span></div><div class="line">hdparm -i /dev/hda      <span class="comment"># 查看磁盘参数(仅适用于IDE设备)</span></div><div class="line">dmesg | grep IDE        <span class="comment"># 查看启动时IDE设备检测状况</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>网络</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ifconfig                <span class="comment"># 查看所有网络接口的属性</span></div><div class="line">iptables -nvL           <span class="comment"># 查看防火墙设置</span></div><div class="line">route -n                <span class="comment"># 查看路由表</span></div><div class="line">netstat -lntp           <span class="comment"># 查看所有监听端口</span></div><div class="line">netstat -antp           <span class="comment"># 查看所有已经建立的连接</span></div><div class="line">netstat <span class="_">-s</span>              <span class="comment"># 查看网络统计信息</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>进程</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ps -ef                  <span class="comment"># 查看所有进程</span></div><div class="line">ps aux                  <span class="comment"># 查看所有进程</span></div><div class="line">lsof                    <span class="comment"># 查看所有进程打开的文件</span></div><div class="line">top                     <span class="comment"># 实时显示进程状态</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>用户</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">w                       <span class="comment"># 查看活动用户</span></div><div class="line">whoami                  <span class="comment"># 查看当前登录用户</span></div><div class="line">id &lt;用户名&gt;             <span class="comment"># 查看指定用户信息</span></div><div class="line">last                    <span class="comment"># 查看用户登录日志</span></div><div class="line">cut <span class="_">-d</span>: <span class="_">-f</span>1 /etc/passwd <span class="comment"># 查看系统所有用户</span></div><div class="line">cut <span class="_">-d</span>: <span class="_">-f</span>1 /etc/group  <span class="comment"># 查看系统所有组</span></div><div class="line">crontab <span class="_">-l</span>              <span class="comment"># 查看当前用户的计划任务</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>服务</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chkconfig --list            <span class="comment"># 列出所有系统服务</span></div><div class="line">chkconfig --list | grep on  <span class="comment"># 列出所有启动的系统服务</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>RPM程序包</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -qa                <span class="comment"># 查看所有安装的软件包</span></div><div class="line">rpm -qi &lt;包名&gt;         <span class="comment"># 查看已安装软件包相关信息</span></div><div class="line">rpm -qpi &lt;包名&gt;        <span class="comment"># 查看未安装软件包相关信息</span></div></pre></td></tr></table></figure><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里仅仅只是记录一些常用的获取系统信息的命令，其他更多命令请参考官方文档。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础" scheme="http://chen-hao.com.cn/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="shell" scheme="http://chen-hao.com.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6结合Busybox完成自制Linux系统</title>
    <link href="http://chen-hao.com.cn/CentOS6%E7%BB%93%E5%90%88Busybox%E5%AE%8C%E6%88%90%E8%87%AA%E5%88%B6Linux%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://chen-hao.com.cn/CentOS6结合Busybox完成自制Linux系统.html</id>
    <published>2016-09-19T03:58:02.000Z</published>
    <updated>2016-09-20T09:10:02.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文主要介绍基于busybox上制作一个小巧版的linux，一般发行版的体积太过庞大，很多功能可能我们碰都不会去碰。那么我就在想可不可以自己裁剪内核和外围的应用程序，制作自己的Linux系统。答案是肯定的，现在就开始制作自己的Linux系统吧。<br><a id="more"></a></p>
</blockquote>
<p></p><h2>环境准备阶段</h2><p></p>
<ol>
<li>一个Centos主机（本文采用的是6.8，其他版本请自行测试）</li>
<li>额外添加一块硬盘（后面用来当做系统盘使用）</li>
<li>下载内核程序包（这里用的版本是3.19.1，<a href="http://mirrors.aliyun.com/linux-kernel/v3.0/" target="_blank" rel="external">阿里云下载地址</a>）</li>
<li>下载Busybox程序包（<a href="http://www.busybox.net" target="_blank" rel="external">下载地址</a>）</li>
</ol>
<p></p><h2>磁盘配置</h2><p></p>
<ol>
<li>新建3个分区<br>第一个主分区(做boot分区)：200M<br>第二个主分区(做/根分区)：20G<br>第三个主分区(做swap分区)：2G<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mkfs.ext4 /dev/sda1</div><div class="line">mkfs.ext4 /dev/sda2</div><div class="line">mkswap /dev/sda3</div><div class="line">mkdir -pv /mnt/&#123;boot,sysroot&#125;</div><div class="line">mount /dev/sda1 /mnt/boot/</div><div class="line">mount /dev/sda2 /mnt/sysroot/</div></pre></td></tr></table></figure>
</li>
</ol>
<p></p><h2>编译内核</h2><p></p>
<ol>
<li><p>下载完程序包，解压缩至/usr/src目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -Jxf linux-3.13.6.tar.xz -C /usr/src/</div><div class="line"><span class="built_in">cd</span> /usr/src/</div><div class="line">ln -sv linux-3.13.6 linux</div><div class="line"><span class="built_in">cd</span> linux</div></pre></td></tr></table></figure>
</li>
<li><p>安装相关依赖包和包组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum groupinstall -y <span class="string">"Development tools"</span> <span class="string">"Server Platform Development"</span></div><div class="line">yum install -y ncurses-devel glibc-static libmcrypt-devel</div></pre></td></tr></table></figure>
</li>
<li><p>根据实际需求选择需要的功能编译内核</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">make allnoconfig</div><div class="line">make menuconfig</div><div class="line"><span class="comment"># 我们把这些内容全部编译进内核、不编译成模块、*号表示编译进内核(M表示以模块的方式装载)</span></div><div class="line"><span class="comment"># 注意：以下*号标识的选项一定要选择*号，否则系统无法正常启动</span></div><div class="line"></div><div class="line">[*]64-bit kernel ：64位操作系统的内核</div><div class="line">General setup --&gt; Local version --&gt; -MyLinux: 给内核定一个自己的版本</div><div class="line">Processor <span class="built_in">type</span> and features --&gt; Processor family --&gt; (X)Generic-x86-64：这里是CPU类型、这个是通用x86-64</div><div class="line">Processor <span class="built_in">type</span> and features --&gt; [*]Symmetric multi-processing support：选择CPU支持多核心处理</div><div class="line">[*]Enable loadable module support: 选择内核动态模块加载</div><div class="line">Bus options (PCI etc.) --&gt; [*]PCI suppor：支持PCI总线</div><div class="line">Device Drivers --&gt; &lt;*&gt;SCSI device support --&gt;[*]SCSI disk support要支持SCSI硬盘</div><div class="line">Device Drivers --&gt;Fusion MPT device support (NEW) --&gt; &lt;*&gt;Fusion MPT ScsiHost drivers <span class="keyword">for</span> SPI、&lt;*&gt;Fusion MPT misc device (ioctl) driver、[*]Fusion MPT logging facility：支持对硬盘的驱动</div><div class="line">File systems --&gt; &lt;*&gt;The Extended 4 (ext4) filesystem：支持文件系统</div><div class="line">Executable file formats / Emulations --&gt; [*]Kernel support <span class="keyword">for</span> ELF binaries、[*]Write ELF core dumps with partial segments (NEW)、 &lt;*&gt;Kernel support <span class="keyword">for</span> scripts starting with <span class="comment">#!:可执行文件的格式</span></div><div class="line">Device Drivers --&gt;Input device support --&gt; [*]Keyboards -&gt; &lt;*&gt;AT keyboard (NEW) [*]Mice：支持输入输出设备、比如健盘</div><div class="line">Device Drivers &gt; Generic Driver Options &gt; [*] Maintain a devtmpfs filesystem to mount at /dev [*]Automount devtmpfs at /dev, after the kernel mounted the rootfs</div><div class="line">[*] Networking support  ---&gt; &gt; Networking options[*] TCP/IP networking [*]IP:multicasting [*]IP: advanced router [*]IP: policy routing [*]IP: verbose route monitoring [*]IP: kernel level autoconfiguration [*]IP: DHCP support [*]IP: BOOTP support [*]IP: RARP support &lt;*&gt;IP: tunneling &lt;*&gt;Unix domain sockets &lt;*&gt;UNIX: socket monitoring interface：支持协议</div><div class="line">Device Drivers &gt; Network device support &gt; Ethernet driver support[*]Intel devices (NEW)&lt;*&gt;Intel(R) PRO/1000 Gigabit Ethernet support&lt;*&gt;Intel(R) PRO/1000 PCI-Express Gigabit Ethernet support：只要Intel的、其他的他都去掉、这是选择网卡设备的驱动程序</div><div class="line"></div><div class="line">OK、到这里保存退出、把配置文件备份一份出来</div><div class="line">cp .config /root/3.13.6.ch-x86_64</div><div class="line">make SUBDIR=/arch     <span class="comment">#开始编译内核，这里时间较长，耐心等待的过程中可以做一点其他的事</span></div><div class="line">cp arch/x86_64/boot/bzImage /mnt/boot/     <span class="comment"># 编译完成之后将文件拷入到boot目录下</span></div><div class="line">grub-install --root-directory=/mnt hd1     <span class="comment"># 安装grub</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p></p><h2>编译Busybox</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xf busybox-20160822.tar.bz2 -C /usr/<span class="built_in">local</span>/</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/busybox</div><div class="line">make menuconfig</div></pre></td></tr></table></figure><p></p>
<p>make menuconfig时就选择这项就可以了、其他的都使用默认选项：<br>Busybox Settings –&gt;Build Options –&gt;[*] Build BusyBox as a static binary (no shared libs)：把busybox编译也静态二进制，不用共享库<br><img src="/uploads/busybox.png" class="blockquote-center"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make </div><div class="line">make install</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要介绍基于busybox上制作一个小巧版的linux，一般发行版的体积太过庞大，很多功能可能我们碰都不会去碰。那么我就在想可不可以自己裁剪内核和外围的应用程序，制作自己的Linux系统。答案是肯定的，现在就开始制作自己的Linux系统吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一键安装cobbler脚本</title>
    <link href="http://chen-hao.com.cn/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85cobbler%E8%84%9A%E6%9C%AC.html"/>
    <id>http://chen-hao.com.cn/一键安装cobbler脚本.html</id>
    <published>2016-09-05T06:57:10.000Z</published>
    <updated>2016-09-05T09:28:11.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这里推荐一个自己写的cobbler安装脚本，在centos6系统上测试没问题，其他环境请自行测试。已关闭selinux和iptables，在大环境下批量部署服务器的情况下还是很好用的……<br> <a id="more"></a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment">#一键安装cobbler脚本,本脚本仅在centos6上验证过，其他环境请自行测试</span></div><div class="line"><span class="comment">#ch </span></div><div class="line"><span class="comment">#2016-09-05</span></div><div class="line"><span class="comment">#coding=utf8</span></div><div class="line"><span class="comment">##################################################################</span></div><div class="line"><span class="comment">#将如下IP修改成你cobbler服务器的IP地址</span></div><div class="line">ip=192.168.16.65</div><div class="line"><span class="comment">#将如下net修改成你Cobbler所在网段的NET  </span></div><div class="line">net=192.168.16.0  </div><div class="line"><span class="comment">#修改成dhcp计划分配的IP段</span></div><div class="line">begin=192.168.16.250</div><div class="line">end=192.168.16.253</div><div class="line"><span class="comment">#web用户/密码</span></div><div class="line">USER=ch</div><div class="line">PASSWD=123456</div><div class="line"><span class="comment">##################################################################</span></div><div class="line"></div><div class="line"><span class="comment"># 安装前请确定配置好epel源</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>    www.chen-hao.com.cn"</span> &gt;&gt; /etc/hosts</div><div class="line">yum install -y cobbler cobbler-web pykickstart dhcp debmirror syslinux cman fence-agents</div><div class="line">/etc/init.d/iptables stop</div><div class="line">/etc/init.d/httpd start</div><div class="line">/etc/init.d/cobblerd start</div><div class="line">service cobblerd restart</div><div class="line">sed -i <span class="_">-e</span> <span class="string">'s/= yes/= no/g'</span> /etc/xinetd.d/rsync</div><div class="line">sed -i <span class="_">-e</span> <span class="string">'s/= yes/= no/g'</span> /etc/xinetd.d/tftp</div><div class="line">sed -i <span class="string">'s@next_server: 127.0.0.1@next_server: '</span><span class="variable">$ip</span><span class="string">'@g'</span> /etc/cobbler/settings</div><div class="line">sed -i <span class="string">'s@server: 127.0.0.1@server: '</span><span class="variable">$ip</span><span class="string">'@g'</span> /etc/cobbler/settings</div><div class="line">cp /usr/share/syslinux/pxelinux.0 /var/lib/cobbler/loaders/</div><div class="line">cp /usr/share/syslinux/menu.c32 /var/lib/cobbler/loaders/</div><div class="line">sed -i <span class="string">'s$@arches="i386"$#@arches="i386"$g'</span> /etc/debmirror.conf</div><div class="line">sed  -i <span class="string">'s$@dists="sid"$#@dists="sid"$g'</span> /etc/debmirror.conf</div><div class="line">sed -i <span class="string">'s@default_password_crypted@#default_password_crypted@g'</span> /etc/cobbler/settings</div><div class="line"><span class="built_in">echo</span> <span class="string">"default_password_crypted:  "</span><span class="variable">$1</span><span class="variable">$ac756ac7</span><span class="variable">$erF27Ljjp3rDItLVqHLOg</span>/<span class="string">""</span> &gt;&gt; /etc/cobbler/settings</div><div class="line">cobbler get-loaders</div><div class="line">service cobblerd restart</div><div class="line">cobbler sync</div><div class="line"><span class="comment">####用cobbler check 查看到底有哪些步骤没有操作完成。</span></div><div class="line">cobbler check</div><div class="line"></div><div class="line"><span class="comment"># dhcp配置 </span></div><div class="line">cat &gt; /etc/dhcp/dhcpd.conf &lt;&lt;EOF</div><div class="line">option domain-name <span class="string">"xiaoluo.com"</span>;</div><div class="line">option domain-name-servers <span class="variable">$ip</span>;</div><div class="line">default-lease-time 43200;</div><div class="line">max-lease-time 86400;</div><div class="line"><span class="built_in">log</span>-facility <span class="built_in">local</span>7;</div><div class="line">subnet <span class="variable">$net</span> netmask 255.255.255.0 &#123;</div><div class="line">     range <span class="variable">$begin</span> <span class="variable">$end</span>;</div><div class="line">     option routers <span class="variable">$ip</span>;</div><div class="line">&#125;</div><div class="line">next-server <span class="variable">$ip</span>;</div><div class="line">filename=<span class="string">"pxelinux.0"</span>;</div><div class="line">EOF</div><div class="line"></div><div class="line"><span class="comment"># 这里需要提前挂载好磁盘镜像文件，请自行准备好ISO文件</span></div><div class="line">/etc/init.d/dhcpd restart</div><div class="line">service xinetd  restart</div><div class="line">service cobblerd restart</div><div class="line">mkdir -p /opt/xiaoluo</div><div class="line">mount /dev/cdrom /opt/xiaoluo  </div><div class="line">cobbler import --name=centos-6.6-x86_64 --path=/opt/xiaoluo</div><div class="line"></div><div class="line"><span class="comment"># cobbler web安装配置 </span></div><div class="line">useradd <span class="variable">$USER</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWD</span>"</span> | passwd --stdin <span class="variable">$USER</span></div><div class="line">sed -i <span class="string">'s/module = authn_configfile/module = authn_pam/g'</span> /etc/cobbler/modules.conf</div><div class="line">sed -i <span class="string">'s/admin = ""/admin="$USER"/g'</span> /etc/cobbler/users.conf</div><div class="line">service cobblerd restart</div><div class="line">service httpd restart</div><div class="line"></div><div class="line"><span class="comment"># 判断网站是否可以正常访问</span></div><div class="line"><span class="keyword">if</span> [[  `curl -I -m 10 -o /dev/null <span class="_">-s</span> -w %&#123;http_code&#125; <span class="variable">$ip</span>/cobbler_web` <span class="_">-eq</span> 200 ]];<span class="keyword">then</span></div><div class="line">cat &lt;&lt; EOF</div><div class="line">+--------------------------+</div><div class="line">+网站正常启动:             +</div><div class="line">+访问地址: <span class="variable">$ip</span>/cobbler_web +</div><div class="line">+用户名: <span class="variable">$USER</span>             + </div><div class="line">+密码: <span class="variable">$PASSWD</span>             +</div><div class="line">+--------------------------+</div><div class="line">EOF</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">echo</span> <span class="string">"error,安装配置错误,请检查配置"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里推荐一个自己写的cobbler安装脚本，在centos6系统上测试没问题，其他环境请自行测试。已关闭selinux和iptables，在大环境下批量部署服务器的情况下还是很好用的……&lt;br&gt;
    
    </summary>
    
      <category term="shell" scheme="http://chen-hao.com.cn/categories/shell/"/>
    
    
      <category term="cobbler" scheme="http://chen-hao.com.cn/tags/cobbler/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-monitor-simple 监控中心安装</title>
    <link href="http://chen-hao.com.cn/dubbo-monitor-simple-%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E5%AE%89%E8%A3%85.html"/>
    <id>http://chen-hao.com.cn/dubbo-monitor-simple-监控中心安装.html</id>
    <published>2016-09-03T02:26:00.000Z</published>
    <updated>2016-09-03T03:03:18.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。本文主要讲解怎么安装此监控系统……<br><a id="more"></a></p>
</blockquote>
<p></p><h2>依赖组件</h2><p></p>
<ul>
<li>java jdk 1.6及以上</li>
<li>git </li>
<li>maven</li>
<li>zookeeper </li>
</ul>
<p></p><h2>获取源代码</h2><br>从github上下载dubbo源码进行编译，下载地址为 <a href="https://github.com/alibaba/dubbo.git" target="_blank" rel="external">dubbo github地址</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/alibaba/dubbo.git</div><div class="line"><span class="built_in">cd</span> dubbo </div><div class="line">mvn clean install -Dmaven.test.skip</div><div class="line"><span class="comment"># 此步骤可能极慢，也可以直接google直接下载.tar.gz的包直接安装即可</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>安装monitor</h2><br>编译打包dubbo源码后，可以找到dubbo-monitor-simple-2.5.4-SNAPSHOT-assembly.tar.gz安装包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">tar -zxf dubbo-monitor-simple-2.5.4-SNAPSHOT-assembly.tar.gz -C /usr/<span class="built_in">local</span></div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/dubbo-monitor-simple</div><div class="line">vim conf/dubbo.properties  <span class="comment"># 修改配置文件</span></div><div class="line">dubbo.container=<span class="built_in">log</span>4j,spring,registry,jetty</div><div class="line">dubbo.application.name=simple-monitor</div><div class="line">dubbo.application.owner=</div><div class="line"><span class="comment">#dubbo.registry.address=multicast://224.5.6.7:1234     # 注释掉19行</span></div><div class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181      <span class="comment"># 修改为 zookeeper服务器的ip地址端口号，如果你的zookeeper是集群，则注册地址修改为zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183</span></div><div class="line"><span class="comment">#dubbo.registry.address=redis://127.0.0.1:7000         # 连接redis的端口</span></div><div class="line"><span class="comment">#dubbo.registry.address=dubbo://123.56.243.77:9090</span></div><div class="line">dubbo.protocol.port=7070</div><div class="line">dubbo.jetty.port=8080</div><div class="line">dubbo.jetty.directory=<span class="variable">$&#123;user.home&#125;</span>/monitor</div><div class="line">dubbo.charts.directory=<span class="variable">$&#123;dubbo.jetty.directory&#125;</span>/charts</div><div class="line">dubbo.statistics.directory=<span class="variable">$&#123;user.home&#125;</span>/monitor/statistics</div><div class="line">dubbo.log4j.file=logs/dubbo-monitor-simple.log</div><div class="line">dubbo.log4j.level=WARN</div><div class="line"><span class="comment"># 其他的配置默认就行，当然也可以自己配置。</span></div></pre></td></tr></table></figure><p></p>
<p></p><h2>启动monitor</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tail <span class="_">-f</span> /usr/<span class="built_in">local</span>/dubbo-monitor-simple-2.5.3/logs/stdout.log</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/dubbo-monitor-simple-2.5.3/bin</div><div class="line">./start.sh</div><div class="line">Starting the simple-monitor .....OK!</div><div class="line">PID: 30864</div><div class="line">STDOUT: logs/stdout.log</div><div class="line"><span class="comment"># 出现以上输出证明启动OK了</span></div></pre></td></tr></table></figure><p></p>
<p>浏览器访问<a href="http://IP:8080/即可显示页面" target="_blank" rel="external">http://IP:8080/即可显示页面</a><br><img src="/uploads/moniotr.png" class="blockquote-center"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。本文主要讲解怎么安装此监控系统……&lt;br&gt;
    
    </summary>
    
      <category term="监控" scheme="http://chen-hao.com.cn/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="dubbo-monitor-simple" scheme="http://chen-hao.com.cn/tags/dubbo-monitor-simple/"/>
    
  </entry>
  
  <entry>
    <title>在Linux中测试网络带宽</title>
    <link href="http://chen-hao.com.cn/%E5%9C%A8Linux%E4%B8%AD%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD.html"/>
    <id>http://chen-hao.com.cn/在Linux中测试网络带宽.html</id>
    <published>2016-09-02T01:29:55.000Z</published>
    <updated>2016-09-02T02:21:11.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近老感觉服务器特别卡，但是光凭感觉可不行啊，要怎么去量化这个呢，例如上行带宽多少，下行带宽多少。于是在github上找到了一个Linux上测试网络带宽的工具了（其实就是一个Python脚本），Speedtest.net的工作原理：它在你的浏览器中加载JavaScript代码并自动检测离你最近的Speedtest.net服务器，然后向服务器发送HTTP GET and POST请求来测试上行/下行网速。<br> <a id="more"></a></p>
</blockquote>
<p></p><h2>安装speedtest-cli</h2><p></p>
<ul>
<li>以下任何一种方式安装即可（总有一款适合你）</li>
</ul>
<p></p><h3>pip / easy_install</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install speedtest-cli</div></pre></td></tr></table></figure><p></p>
<p>or<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">easy_install speedtest-cli</div></pre></td></tr></table></figure></p>
<p></p><h3>github</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install git+https://github.com/sivel/speedtest-cli.git</div></pre></td></tr></table></figure><p></p>
<p>or<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/sivel/speedtest-cli.git</div><div class="line">python speedtest-cli/setup.py install</div></pre></td></tr></table></figure></p>
<p></p><h3>download</h3><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest_cli.py</div><div class="line">chmod +x speedtest-cli</div></pre></td></tr></table></figure><p></p>
<p>or<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -Lo speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest_cli.py</div><div class="line">chmod +x speedtest-cli</div></pre></td></tr></table></figure></p>
<p></p><h2>使用方法</h2><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ speedtest-cli -h</div><div class="line">usage: speedtest-cli [-h] [--bytes] [--share] [--simple] [--list]</div><div class="line">                     [--server SERVER] [--mini MINI] [--source SOURCE]</div><div class="line">                     [--timeout TIMEOUT] [--secure] [--version]</div><div class="line"></div><div class="line">Command line interface <span class="keyword">for</span> testing internet bandwidth using speedtest.net.</div><div class="line">--------------------------------------------------------------------------</div><div class="line">https://github.com/sivel/speedtest-cli</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help         显示帮助</div><div class="line">  --bytes            以字节的方式显示，但分享的时候不受影响</div><div class="line">  --share            分享</div><div class="line">  --simple           只显示简单信息</div><div class="line">  --list             显示speedtest.net服务器列表</div><div class="line">  --server SERVER    指定speedtest.net服务器ID</div><div class="line">  --source SOURCE    指定源IP地址</div><div class="line">  --timeout TIMEOUT  指定超时时间，默认10秒</div><div class="line">  --secure           使用HTTPS协议进行通信</div><div class="line">  --version          显示当前版本</div></pre></td></tr></table></figure><p></p>
<p></p><h2>使用示例</h2><br><img src="/uploads/speedtest.gif" class="blockquote-center"><p></p>
<ul>
<li>到最后，贴出这个脚本的github地址吧。  <a href="https://github.com/sivel/speedtest-cli" target="_blank" rel="external">speedtest-cli github地址</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近老感觉服务器特别卡，但是光凭感觉可不行啊，要怎么去量化这个呢，例如上行带宽多少，下行带宽多少。于是在github上找到了一个Linux上测试网络带宽的工具了（其实就是一个Python脚本），Speedtest.net的工作原理：它在你的浏览器中加载JavaScript代码并自动检测离你最近的Speedtest.net服务器，然后向服务器发送HTTP GET and POST请求来测试上行/下行网速。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://chen-hao.com.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="speedtest-cli" scheme="http://chen-hao.com.cn/tags/speedtest-cli/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump全量和增量备份脚本</title>
    <link href="http://chen-hao.com.cn/mysqldump%E5%85%A8%E9%87%8F%E5%92%8C%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC.html"/>
    <id>http://chen-hao.com.cn/mysqldump全量和增量备份脚本.html</id>
    <published>2016-09-01T06:10:16.000Z</published>
    <updated>2016-09-01T06:14:38.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>写好了xtrabackup的备份脚本才发现线上数据库是5.1的，既然这样那就只有用mysqldump来备份了。不过好在mysqldump更简单，只需要简单的一两条命令即可，增量备份使用复制binlog的方式来实现，后期恢复直接跑二进制日志即可。<br> <a id="more"></a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># mysqldump 全量和增量备份</span></div><div class="line"><span class="comment"># ch</span></div><div class="line"><span class="comment"># 2016-09-01</span></div><div class="line"></div><div class="line"><span class="comment"># 基础环境变量设置</span></div><div class="line">USER=root</div><div class="line">PASSWD=123456</div><div class="line">HOST=localhost</div><div class="line">LOG_DIR=/home/backup/backup.log</div><div class="line">BIN_DIR=/home/mysql_data</div><div class="line">BIN_FILE=<span class="variable">$BIN_DIR</span>/master1_bin.index</div><div class="line">DATE=`date +%Y%m%d`</div><div class="line">DUMPFILE=<span class="string">"<span class="variable">$DATE</span>"</span>.sql</div><div class="line">GZDUMPFILE=<span class="string">"<span class="variable">$DATE</span>"</span>.sql.tgz</div><div class="line"></div><div class="line"><span class="comment"># 检查环境是否配置正确</span></div><div class="line"><span class="function"><span class="title">check</span></span>()&#123;	</div><div class="line">	<span class="keyword">if</span> [[ ! <span class="string">"mysql -h"</span><span class="variable">$HOST</span><span class="string">" -u"</span><span class="variable">$USER</span><span class="string">" -p"</span><span class="variable">$PASSWD</span><span class="string">" -e 'show databases;'"</span> ]];<span class="keyword">then</span></div><div class="line">		<span class="built_in">echo</span> <span class="string">"<span class="variable">$DATE</span>,客户端连接错误,备份失败"</span> &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">		<span class="built_in">exit</span> 2</div><div class="line">	<span class="keyword">fi</span></div><div class="line">	<span class="keyword">if</span> [ ! <span class="_">-d</span> <span class="variable">$BIN_DIR</span> ];<span class="keyword">then</span></div><div class="line">		<span class="built_in">echo</span> <span class="string">"BIN_DIR路径错误，请检查后重试"</span> &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">		<span class="built_in">exit</span> 3</div><div class="line">	<span class="keyword">fi</span></div><div class="line">	<span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="variable">$BIN_FILE</span> ];<span class="keyword">then</span></div><div class="line">		<span class="built_in">echo</span> <span class="string">"BIN_FILE路径错误，请检查后重试"</span> &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">		<span class="built_in">exit</span> 4</div><div class="line">	<span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 全量备份</span></div><div class="line"><span class="function"><span class="title">full</span></span>()&#123;</div><div class="line">	BACK_DIR=/home/backup/full</div><div class="line">	<span class="keyword">if</span> [ ! <span class="_">-d</span> <span class="variable">$BACK_DIR</span> ];<span class="keyword">then</span></div><div class="line">		mkdir -p <span class="variable">$BACK_DIR</span></div><div class="line">	<span class="keyword">fi</span></div><div class="line">	BEGIN=`date +<span class="string">"%Y年%m月%d日 %H:%M:%S"</span>`</div><div class="line">	<span class="built_in">cd</span> <span class="variable">$BACK_DIR</span></div><div class="line">	mysqldump -h<span class="string">"<span class="variable">$HOST</span>"</span> -u<span class="string">"<span class="variable">$USER</span>"</span> -p<span class="string">"<span class="variable">$PASSWD</span>"</span> -A -E -R --triggers --master-data=2 <span class="_">-l</span> --flush-logs &gt; <span class="variable">$DUMPFILE</span> || <span class="built_in">echo</span> <span class="string">"备份出错"</span> &gt;&gt; <span class="variable">$LOG_DIR</span>  </div><div class="line">	tar czvf <span class="variable">$GZDUMPFILE</span> <span class="variable">$DUMPFILE</span> &amp;&gt; /dev/null &amp;&amp; rm -rf <span class="variable">$DUMPFILE</span></div><div class="line">	LAST=`date +<span class="string">"%Y年%m月%d日 %H:%M:%S"</span>`</div><div class="line">	POSITION=$(mysql -h<span class="string">"<span class="variable">$HOST</span>"</span> -u<span class="string">"<span class="variable">$USER</span>"</span> -p<span class="string">"<span class="variable">$PASSWD</span>"</span> <span class="_">-e</span> <span class="string">'show master status\G'</span> | grep  Position | awk -F: <span class="string">'&#123;print $2&#125;'</span>)</div><div class="line">	BINFILE=$(mysql -h<span class="string">"<span class="variable">$HOST</span>"</span> -u<span class="string">"<span class="variable">$USER</span>"</span> -p<span class="string">"<span class="variable">$PASSWD</span>"</span> <span class="_">-e</span> <span class="string">'show master status\G'</span> | grep  File | awk -F: <span class="string">'&#123;print $2&#125;'</span>)</div><div class="line"></div><div class="line">	<span class="built_in">echo</span> <span class="string">"全量备份开始: <span class="variable">$BEGIN</span>"</span> &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"全量备份结束: <span class="variable">$LAST</span> <span class="variable">$GZDUMPFILE</span> <span class="variable">$BINFILE</span> <span class="variable">$POSITION</span>"</span> Bakup succ! &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 增量备份</span></div><div class="line"><span class="function"><span class="title">inc</span></span>()</div><div class="line">&#123;</div><div class="line">	BACK_DIR=/home/backup/inc</div><div class="line">	<span class="keyword">if</span> [ ! <span class="_">-d</span> <span class="variable">$BACK_DIR</span> ];<span class="keyword">then</span></div><div class="line">        mkdir -p <span class="variable">$BACK_DIR</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">	mysqladmin -u<span class="variable">$USER</span> -p<span class="variable">$PASSWD</span> flush-logs</div><div class="line">	COUNTER=`wc <span class="_">-l</span> <span class="variable">$BIN_FILE</span> | awk <span class="string">'&#123;print$1&#125;'</span>`</div><div class="line">	NEXTNUM=0</div><div class="line">	BEGIN=`date +<span class="string">"%Y年%m月%d日 %H:%M:%S"</span>`</div><div class="line">	<span class="built_in">echo</span> <span class="string">"增量备份开始: <span class="variable">$BEGIN</span>"</span> &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">		<span class="keyword">for</span> file <span class="keyword">in</span> `cat <span class="variable">$BIN_FILE</span>`</div><div class="line">		<span class="keyword">do</span></div><div class="line">			base=`basename <span class="variable">$file</span>`</div><div class="line">			NETXNUM=`expr <span class="variable">$NEXTNUM</span>+1`</div><div class="line">			<span class="keyword">if</span> [ <span class="variable">$NEXTNUM</span> <span class="_">-eq</span> <span class="variable">$COUNTER</span> ]</div><div class="line">			<span class="keyword">then</span></div><div class="line">				<span class="built_in">echo</span> <span class="variable">$base</span> skip! &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">			<span class="keyword">else</span></div><div class="line">				dest=<span class="variable">$BACK_DIR</span>/<span class="variable">$base</span></div><div class="line">				<span class="keyword">if</span> (<span class="built_in">test</span> <span class="_">-e</span> <span class="variable">$dest</span>)</div><div class="line">				<span class="keyword">then</span></div><div class="line">					<span class="built_in">echo</span> <span class="variable">$base</span> exits! &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">				<span class="keyword">else</span></div><div class="line">					cp <span class="variable">$BIN_DIR</span>/<span class="variable">$base</span> <span class="variable">$BACK_DIR</span></div><div class="line">					<span class="built_in">echo</span> <span class="variable">$base</span> copying! &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">				<span class="keyword">fi</span></div><div class="line">			<span class="keyword">fi</span></div><div class="line">		<span class="keyword">done</span></div><div class="line">	LAST=`date +<span class="string">"%Y年%m月%d日 %H:%M:%S"</span>`</div><div class="line">	<span class="built_in">echo</span> <span class="string">"增量备份结束: <span class="variable">$LAST</span>"</span> <span class="variable">$Next</span> <span class="variable">$BACK_DIR</span> Bakup succ! &gt;&gt; <span class="variable">$LOG_DIR</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></div><div class="line">	full)</div><div class="line">		check</div><div class="line">        full</div><div class="line">        ;;</div><div class="line">	inc)</div><div class="line">		check</div><div class="line">        inc</div><div class="line">        ;;</div><div class="line">	 *)</div><div class="line">cat &lt;&lt; EOF</div><div class="line">+----------------+</div><div class="line">+ Use:           +</div><div class="line">+ full  全量备份 +</div><div class="line">+ inc   增量备份 +</div><div class="line">+----------------+</div><div class="line">EOF</div><div class="line">      	;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写好了xtrabackup的备份脚本才发现线上数据库是5.1的，既然这样那就只有用mysqldump来备份了。不过好在mysqldump更简单，只需要简单的一两条命令即可，增量备份使用复制binlog的方式来实现，后期恢复直接跑二进制日志即可。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chen-hao.com.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysqldump" scheme="http://chen-hao.com.cn/tags/mysqldump/"/>
    
  </entry>
  
  <entry>
    <title>xtrabackup自动恢复脚本</title>
    <link href="http://chen-hao.com.cn/xtrabackup%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E8%84%9A%E6%9C%AC.html"/>
    <id>http://chen-hao.com.cn/xtrabackup自动恢复脚本.html</id>
    <published>2016-09-01T00:29:17.000Z</published>
    <updated>2016-09-01T03:50:24.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>此脚本是搭配上一个全量和增量备份脚本搭配使用的，换做其他环境，我觉得应该是没什么用。所以说，还是先理解了第一个备份的脚本才能使用这个自动恢复脚本，此恢复脚本严重依赖 $LOG_DIR 目录，如 LOG_DIR 目录手动更改，会导致增量恢复故障。全量恢复可随意使用<br> <a id="more"></a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># MySQL全量和增量恢复（和MySQL备份脚本搭配使用）</span></div><div class="line"><span class="comment"># ch</span></div><div class="line"><span class="comment"># 2016-8-29</span></div><div class="line"></div><div class="line"><span class="comment"># 初始变量设置</span></div><div class="line">Innobackupex_Path=/usr/bin/innobackupex                      <span class="comment">#innobackupex软件文件</span></div><div class="line">Mysql_Client=/usr/bin/mysql                                  <span class="comment">#mysql客户端</span></div><div class="line">Mysql_Conf=/etc/my.cnf                                       <span class="comment">#mysql配置文件</span></div><div class="line">Mysql_Dir=$(cat <span class="variable">$Mysql_Conf</span> | grep datadir | awk -F <span class="string">'='</span> <span class="string">'&#123;print$2&#125;'</span>)</div><div class="line">BACKUP_DIR=/home/backup/mysql/file/`date +%F-%T`</div><div class="line">MYSQL_OPS=<span class="string">'--host=localhost --user=root --password=123456'</span>   <span class="comment">#mysql的连接配置，按需修改</span></div><div class="line">BACKUP_FULL=/home/backup/mysql/full</div><div class="line">BACKUP_INC=/home/backup/mysql/inc</div><div class="line">LOG_DIR=/home/backup/mysql/backup.log</div><div class="line">ERROR_LOG=/home/backup/mysql/error.log</div><div class="line">DATE=`date +%F-%T`</div><div class="line"></div><div class="line"><span class="comment">#环境和配置检查</span></div><div class="line"><span class="function"><span class="title">check</span></span>()</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> [[ ! <span class="_">-d</span> <span class="variable">$BACKUP_DIR</span> ]];<span class="keyword">then</span></div><div class="line">         mkdir -p <span class="variable">$BACKUP_DIR</span></div><div class="line">    <span class="keyword">fi</span>	</div><div class="line">    <span class="comment">#安装软件2.4，需要其他版本请自行官网下载</span></div><div class="line">    <span class="keyword">if</span> [[ ! `rpm -q percona-xtrabackup-24-2.4.4-1.el6.x86_64` ]];<span class="keyword">then</span></div><div class="line">        wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/redhat/6/x86_64/percona-xtrabackup-24-2.4.4-1.el6.x86_64.rpm &amp;&gt; /dev/null</div><div class="line">        yum -y install percona-xtrabackup-24-2.4.4-1.el6.x86_64.rpm &amp;&gt; /dev/null</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> [[ ! <span class="_">-f</span> <span class="variable">$Mysql_Client</span> ]];<span class="keyword">then</span></div><div class="line">        Error <span class="string">"未安装mysql客户端"</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> [[ ! <span class="_">-f</span> <span class="variable">$Mysql_Conf</span> ]];<span class="keyword">then</span></div><div class="line">        Error <span class="string">"mysql配置文件路径不正确"</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="comment">#检查mysql的运行状态</span></div><div class="line">    <span class="keyword">if</span> [[ `netstat -tlnp |grep mysqld |wc <span class="_">-l</span>` = 0 ]];<span class="keyword">then</span></div><div class="line">        Error <span class="string">"MySQL没有运行"</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="comment">#验证mysql的用户和密码是否正确</span></div><div class="line">    <span class="keyword">if</span>  ! `<span class="built_in">echo</span> <span class="string">'exit'</span> | <span class="variable">$Mysql_Client</span> <span class="_">-s</span>  <span class="variable">$MYSQL_OPS</span> &gt;/dev/null 2&gt;&amp;1` ; <span class="keyword">then</span></div><div class="line">        Error <span class="string">"提供的数据库连接配置不正确!"</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment"># 全量恢复</span></div><div class="line"><span class="function"><span class="title">full</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span>	</div><div class="line">    <span class="built_in">read</span> -p <span class="string">"请输入需要恢复的目录:（q/退出,l/获取目录）"</span> FILE</div><div class="line">		<span class="keyword">if</span> [[ <span class="variable">$FILE</span> == l ]];<span class="keyword">then</span></div><div class="line">	    	ls <span class="variable">$BACKUP_FULL</span></div><div class="line">		<span class="keyword">elif</span> [[ <span class="variable">$FILE</span> == q ]];<span class="keyword">then</span></div><div class="line">			<span class="built_in">exit</span> 0</div><div class="line">		<span class="keyword">elif</span> [[ <span class="_">-d</span> <span class="string">"<span class="variable">$BACKUP_FULL</span>/<span class="variable">$FILE</span>"</span> ]];<span class="keyword">then</span></div><div class="line">	    	service mysqld stop</div><div class="line">	    	mv <span class="variable">$Mysql_Dir</span> <span class="variable">$BACKUP_DIR</span></div><div class="line">	    	mkdir -p <span class="variable">$Mysql_Dir</span></div><div class="line">	    	<span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log <span class="string">"<span class="variable">$BACKUP_FULL</span>/<span class="variable">$FILE</span>"</span></div><div class="line">	    	<span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --copy-back <span class="string">"<span class="variable">$BACKUP_FULL</span>/<span class="variable">$FILE</span>"</span></div><div class="line">	    	sleep 3</div><div class="line">            chown -R mysql.mysql <span class="variable">$Mysql_Dir</span></div><div class="line">	    	service mysqld start</div><div class="line">	    	mysql <span class="_">-s</span> <span class="variable">$MYSQL_OPS</span> <span class="_">-e</span> <span class="string">'show databases;'</span> <span class="_">-e</span> <span class="string">'show databases;'</span>&amp;&gt; /dev/null &amp;&amp; rm -rf <span class="variable">$BACKUP_DIR</span> || <span class="built_in">echo</span> <span class="string">"error,恢复出错，详情请查看<span class="variable">$BACKUP_dir</span>"</span> &gt;&gt; <span class="variable">$ERROR_LOG</span></div><div class="line">	    	<span class="built_in">break</span></div><div class="line">		<span class="keyword">else</span></div><div class="line">	    	<span class="built_in">echo</span> <span class="string">"输出有误,直接输入文件名称即可"</span></div><div class="line">		<span class="keyword">fi</span></div><div class="line">    <span class="keyword">done</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 增量恢复</span></div><div class="line"><span class="function"><span class="title">inc</span></span>()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span></div><div class="line">	<span class="built_in">read</span> -p <span class="string">"请输入需要恢复的目录:（q/退出,l/获取目录）"</span> FILE   </div><div class="line">	    <span class="keyword">if</span> [[ <span class="variable">$FILE</span> == l ]];<span class="keyword">then</span></div><div class="line">        	ls <span class="variable">$BACKUP_INC</span></div><div class="line">    	<span class="keyword">elif</span> [[ <span class="variable">$FILE</span> == q ]];<span class="keyword">then</span></div><div class="line">        	<span class="built_in">exit</span> 0</div><div class="line">		<span class="keyword">elif</span> [[ <span class="_">-d</span> <span class="string">"<span class="variable">$BACKUP_INC</span>/<span class="variable">$FILE</span>"</span> ]];<span class="keyword">then</span></div><div class="line">			ZZ=$(grep -B 1 <span class="string">"<span class="variable">$FILE</span>"</span> <span class="variable">$LOG_DIR</span> | grep <span class="string">"^星期"</span> | grep -o <span class="string">"[0-9]"</span>) </div><div class="line">			<span class="keyword">if</span> [[ <span class="variable">$ZZ</span> <span class="_">-eq</span> 7 ]];<span class="keyword">then</span></div><div class="line">				full</div><div class="line">			<span class="keyword">elif</span> [[ <span class="variable">$ZZ</span> <span class="_">-eq</span> 6 ]];<span class="keyword">then</span></div><div class="line">				<span class="comment"># 此处会读取 $LOG_DIR 目录下的日志信息，so，最好不要自己手动改 LOG_DIR 下的信息，否则可能会导致增量恢复出错</span></div><div class="line">				grep -B 14 <span class="string">"<span class="variable">$FILE</span>"</span> <span class="variable">$LOG_DIR</span> &gt;&gt; /tmp/<span class="variable">$DATE</span>.mysql</div><div class="line">				sed -i -n <span class="string">'n;p'</span> /tmp/<span class="variable">$DATE</span>.mysql</div><div class="line">				ONE=$(sed -n <span class="string">'1 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">				TWO=$(sed -n '2 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">				THREE=$(sed -n <span class="string">'3 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">				FOUR=$(sed -n '4 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">				FIVE=$(sed -n <span class="string">'5 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">				SIX=$(sed -n '6 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">				SER=$(sed -n <span class="string">'7 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">					service mysqld stop</div><div class="line">            		mv $Mysql_Dir $BACKUP_DIR</div><div class="line">            		mkdir -p $Mysql_Dir</div><div class="line">            		$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$TWO</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$THREE</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$FOUR</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$FIVE</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$SIX</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$SER</div><div class="line">            		$Innobackupex_Path $MYSQL_OPS --copy-back $ONE</div><div class="line">            		sleep 3</div><div class="line">            		chown -R mysql.mysql $Mysql_Dir</div><div class="line">            		service mysqld start</div><div class="line">            		mysql -s $MYSQL_OPS -e 'show databases;<span class="string">' &amp;&gt; /dev/null &amp;&amp; rm -rf $BACKUP_DIR /tmp/$DATE.mysql || echo "error,恢复出错，&gt;详情请查看$BACKUP_dir" &gt;&gt; $ERROR_LOG</span></div><div class="line">					break</div><div class="line">			elif [[ $ZZ -eq 5 ]];then</div><div class="line">				grep -B 12 "$FILE" $LOG_DIR &gt;&gt; /tmp/$DATE.mysql</div><div class="line">				sed -i -n 'n;p<span class="string">' /tmp/$DATE.mysql</span></div><div class="line">				ONE=$(sed -n '1 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                TWO=$(sed -n <span class="string">'2 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                THREE=$(sed -n '3 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                FOUR=$(sed -n <span class="string">'4 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">               	FIVE=$(sed -n '5 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">				SIX=$(sed -n <span class="string">'6 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">			    	service mysqld stop</div><div class="line">                    mv $Mysql_Dir $BACKUP_DIR</div><div class="line">                   	mkdir -p $Mysql_Dir</div><div class="line">                   	$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE</div><div class="line">                   	$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$TWO</div><div class="line">                   	$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$THREE</div><div class="line">                   	$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$FOUR</div><div class="line">                   	$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$FIVE</div><div class="line">					$Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$SIX</div><div class="line">					sleep 3</div><div class="line">                    chown -R mysql.mysql $Mysql_Dir</div><div class="line">                    service mysqld start</div><div class="line">                    mysql -s $MYSQL_OPS -e 'show databases;<span class="string">' &amp;&gt; /dev/null &amp;&amp; rm -rf $BACKUP_DIR /tmp/$DATE.mysql || echo "error,恢复出错，&gt;详情请查看$BACKUP_dir" &gt;&gt; $ERROR_LOG</span></div><div class="line">					break</div><div class="line">			elif [[ $ZZ -eq 4 ]];then</div><div class="line">				grep -B 10 "$FILE" $LOG_DIR &gt;&gt; /tmp/$DATE.mysql</div><div class="line">                sed -i -n 'n;p<span class="string">' /tmp/$DATE.mysql</span></div><div class="line">                ONE=$(sed -n '1 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                TWO=$(sed -n <span class="string">'2 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                THREE=$(sed -n '3 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                FOUR=$(sed -n <span class="string">'4 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">               	FIVE=$(sed -n '5 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                    service mysqld stop</div><div class="line">                    mv <span class="variable">$Mysql_Dir</span> <span class="variable">$BACKUP_DIR</span></div><div class="line">                    mkdir -p <span class="variable">$Mysql_Dir</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$TWO</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$THREE</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$FOUR</span></div><div class="line">                   	<span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$FIVE</span></div><div class="line">                    sleep 3</div><div class="line">                    chown -R mysql.mysql <span class="variable">$Mysql_Dir</span></div><div class="line">                    service mysqld start</div><div class="line">                    mysql <span class="_">-s</span> <span class="variable">$MYSQL_OPS</span> <span class="_">-e</span> <span class="string">'show databases;'</span> &amp;&gt; /dev/null &amp;&amp; rm -rf <span class="variable">$BACKUP_DIR</span> /tmp/<span class="variable">$DATE</span>.mysql || <span class="built_in">echo</span> <span class="string">"error,恢复出错，&gt;详情请查看<span class="variable">$BACKUP_dir</span>"</span> &gt;&gt; <span class="variable">$ERROR_LOG</span></div><div class="line">					<span class="built_in">break</span></div><div class="line">			<span class="keyword">elif</span> [[ <span class="variable">$ZZ</span> <span class="_">-eq</span> 3 ]];<span class="keyword">then</span></div><div class="line">				grep -B 8 <span class="string">"<span class="variable">$FILE</span>"</span> <span class="variable">$LOG_DIR</span> &gt;&gt; /tmp/<span class="variable">$DATE</span>.mysql</div><div class="line">                sed -i -n <span class="string">'n;p'</span> /tmp/<span class="variable">$DATE</span>.mysql</div><div class="line">                ONE=$(sed -n <span class="string">'1 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                TWO=$(sed -n '2 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                THREE=$(sed -n <span class="string">'3 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                FOUR=$(sed -n '4 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                    service mysqld stop</div><div class="line">                    mv <span class="variable">$Mysql_Dir</span> <span class="variable">$BACKUP_DIR</span></div><div class="line">                    mkdir -p <span class="variable">$Mysql_Dir</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$TWO</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$THREE</span></div><div class="line">                    <span class="variable">$Innobackupex_Path</span> <span class="variable">$MYSQL_OPS</span> --apply-log --redo-only <span class="variable">$ONE</span> --incremental-dir=<span class="variable">$FOUR</span></div><div class="line">                    sleep 3</div><div class="line">                    chown -R mysql.mysql <span class="variable">$Mysql_Dir</span></div><div class="line">                    service mysqld start</div><div class="line">                    mysql <span class="_">-s</span> <span class="variable">$MYSQL_OPS</span> <span class="_">-e</span> <span class="string">'show databases;'</span> <span class="_">-e</span> <span class="string">'show databases;'</span> &amp;&gt; /dev/null &amp;&amp; rm -rf <span class="variable">$BACKUP_DIR</span> /tmp/<span class="variable">$DATE</span>.mysql || <span class="built_in">echo</span> <span class="string">"error,恢复出错，&gt;详情请查看<span class="variable">$BACKUP_dir</span>"</span> &gt;&gt; <span class="variable">$ERROR_LOG</span></div><div class="line">					<span class="built_in">break</span></div><div class="line">			<span class="keyword">elif</span> [[ <span class="variable">$ZZ</span> <span class="_">-eq</span> 2 ]];<span class="keyword">then</span></div><div class="line">				grep -B 6 <span class="string">"<span class="variable">$FILE</span>"</span> <span class="variable">$LOG_DIR</span> &gt;&gt; /tmp/<span class="variable">$DATE</span>.mysql</div><div class="line">                sed -i -n <span class="string">'n;p'</span> /tmp/<span class="variable">$DATE</span>.mysql</div><div class="line">                ONE=$(sed -n <span class="string">'1 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                TWO=$(sed -n '2 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                THREE=$(sed -n <span class="string">'3 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                    service mysqld stop</div><div class="line">                    mv $Mysql_Dir $BACKUP_DIR</div><div class="line">                    mkdir -p $Mysql_Dir</div><div class="line">                    $Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE</div><div class="line">                    $Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$TWO</div><div class="line">                    $Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$THREE</div><div class="line">                    sleep 3</div><div class="line">                    chown -R mysql.mysql $Mysql_Dir</div><div class="line">                    service mysqld start</div><div class="line">                    mysql -s $MYSQL_OPS -e 'show databases;<span class="string">' &amp;&gt; /dev/null &amp;&amp; rm -rf $BACKUP_DIR /tmp/$DATE.mysql || echo "error,恢复出错，&gt;详情请查看$BACKUP_dir" &gt;&gt; $ERROR_LOG</span></div><div class="line">					break</div><div class="line">			elif [[ $ZZ -eq 1 ]];then</div><div class="line">                grep -B 4 "$FILE" $LOG_DIR &gt;&gt; /tmp/$DATE.mysql</div><div class="line">                sed -i -n 'n;p<span class="string">' /tmp/$DATE.mysql</span></div><div class="line">                ONE=$(sed -n '1 p<span class="string">' /tmp/$DATE.mysql) | awk -F \'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">                TWO=$(sed -n <span class="string">'2 p'</span> /tmp/<span class="variable">$DATE</span>.mysql) | awk -F \<span class="string">' '</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">'</span></div><div class="line">                    service mysqld stop</div><div class="line">                    mv $Mysql_Dir $BACKUP_DIR</div><div class="line">                    mkdir -p $Mysql_Dir</div><div class="line">                    $Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE</div><div class="line">                    $Innobackupex_Path $MYSQL_OPS --apply-log --redo-only $ONE --incremental-dir=$TWO</div><div class="line">                    sleep 3</div><div class="line">                    chown -R mysql.mysql $Mysql_Dir</div><div class="line">                    service mysqld start</div><div class="line">                    mysql -s $MYSQL_OPS -e 'show databases;<span class="string">' &amp;&gt; /dev/null &amp;&amp; rm -rf $BACKUP_DIR /tmp/$DATE.mysql || echo "error,恢复出错，&gt;详情请查看$BACKUP_dir" &gt;&gt; $ERROR_LOG</span></div><div class="line">					break</div><div class="line">			else</div><div class="line">					echo "输入目录有误，请重新输入"</div><div class="line">			fi</div><div class="line">		fi</div><div class="line">	done	</div><div class="line">&#125;</div><div class="line"></div><div class="line">case $1 in </div><div class="line">	full)</div><div class="line">		full</div><div class="line">	;;</div><div class="line">	inc)</div><div class="line">		inc</div><div class="line">	;;</div><div class="line">	*)</div><div class="line">cat &lt;&lt; EOF</div><div class="line">+----------------+</div><div class="line">+ Use:           +</div><div class="line">+ full  全量恢复 +</div><div class="line">+ inc   增量恢复 +</div><div class="line">+----------------+</div><div class="line">EOF</div><div class="line">	;;</div><div class="line">esac</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此脚本是搭配上一个全量和增量备份脚本搭配使用的，换做其他环境，我觉得应该是没什么用。所以说，还是先理解了第一个备份的脚本才能使用这个自动恢复脚本，此恢复脚本严重依赖 $LOG_DIR 目录，如 LOG_DIR 目录手动更改，会导致增量恢复故障。全量恢复可随意使用&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chen-hao.com.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="xtrabackup" scheme="http://chen-hao.com.cn/tags/xtrabackup/"/>
    
  </entry>
  
  <entry>
    <title>mysql使用xtrabackup的全量和增量脚本</title>
    <link href="http://chen-hao.com.cn/mysql%E4%BD%BF%E7%94%A8xtrabackup%E7%9A%84%E5%85%A8%E9%87%8F%E5%92%8C%E5%A2%9E%E9%87%8F%E8%84%9A%E6%9C%AC.html"/>
    <id>http://chen-hao.com.cn/mysql使用xtrabackup的全量和增量脚本.html</id>
    <published>2016-08-30T05:16:27.000Z</published>
    <updated>2016-08-30T06:16:27.779Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>需要一个MySQL的自动备份脚本，于是google了一下，发现不是自己看不懂就是运行有问题。那么迫于无赖，不能偷懒了，只能写一个比较适合自己的脚本。脚本较烂，还望轻喷。<br> <a id="more"></a></p>
</blockquote>
<p>上正题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># MySQL全量和增量备份</span></div><div class="line"><span class="comment"># ch</span></div><div class="line"><span class="comment"># www.chen-hao.com.cn</span></div><div class="line"><span class="comment"># 2016-8-29 </span></div><div class="line"></div><div class="line"><span class="comment"># 初始变量配置</span></div><div class="line">Innobackupex_Path=/usr/bin/innobackupex                      <span class="comment">#innobackupex软件文件</span></div><div class="line">Mysql_Client=/usr/bin/mysql                                  <span class="comment">#mysql客户端</span></div><div class="line">Mysql_Conf=/etc/my.cnf                                       <span class="comment">#mysql配置文件</span></div><div class="line">MYSQL_OPS=<span class="string">'--host=localhost --user=root --password=123456'</span>   <span class="comment">#mysql的连接配置，按需修改</span></div><div class="line">BACKUP_FULL=/home/backup/mysql/full                          <span class="comment">#全量备份目录</span></div><div class="line">BACKUP_INC=/home/backup/mysql/inc                            <span class="comment">#增量备份目录</span></div><div class="line">LOG_DIR=/home/backup/mysql/backup.log                        <span class="comment">#日志文件路径</span></div><div class="line">COMPLETE=$(tail -1 <span class="variable">$LOG_DIR</span> | cut <span class="_">-d</span>\<span class="string">' -f2)                  #临时截取上一个增量备份的信息</span></div><div class="line">DATE=`date +%Y%m%d_%H%M%S`                                </div><div class="line">XINQI=`date +%w`											 #此项主要结合增量恢复脚本使用</div><div class="line"></div><div class="line">#环境和配置检查</div><div class="line">check()</div><div class="line">  &#123;</div><div class="line">    #检查目录和创建目录</div><div class="line">    if [[ ! -d $BACKUP_FULL ]];then</div><div class="line">        mkdir -p $BACKUP_FULL</div><div class="line">    fi</div><div class="line"></div><div class="line">    if [[ ! -d $BACKUP_INC ]];then</div><div class="line">        mkdir -p $BACKUP_INC</div><div class="line">    fi</div><div class="line"></div><div class="line">    #安装软件2.4，需要其他版本请自行官网下载</div><div class="line">    if [[ ! `rpm -q percona-xtrabackup-24-2.4.4-1.el6.x86_64` ]];then</div><div class="line">        wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/redhat/6/x86_64/percona-xtrabackup-24-2.4.4-1.el6.x86_64.rpm &amp;&gt; /dev/null</div><div class="line">        yum -y install percona-xtrabackup-24-2.4.4-1.el6.x86_64.rpm &amp;&gt; /dev/null</div><div class="line">    fi</div><div class="line"></div><div class="line">    if [[ ! -f $Mysql_Client ]];then</div><div class="line">        Error "未安装mysql客户端"</div><div class="line">    fi</div><div class="line"></div><div class="line">    if [[ ! -f $Mysql_Conf ]];then</div><div class="line">        Error "mysql配置文件路径不正确"</div><div class="line">    fi</div><div class="line"></div><div class="line">    #检查mysql的运行状态</div><div class="line">    if [[ `netstat -tlnp |grep mysqld |wc -l` = 0 ]];then</div><div class="line">        Error "MySQL没有运行"</div><div class="line">    fi</div><div class="line"></div><div class="line">    #验证mysql的用户和密码是否正确</div><div class="line">    if  ! `echo '<span class="built_in">exit</span><span class="string">' | $Mysql_Client -s  $MYSQL_OPS &gt;/dev/null 2&gt;&amp;1` ; then</span></div><div class="line">        Error "提供的数据库连接配置不正确!"</div><div class="line">    fi</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"># 全量备份</div><div class="line">full()</div><div class="line">&#123;</div><div class="line">	$Innobackupex_Path $MYSQL_OPS $BACKUP_FULL &amp;&gt; /tmp/"$DATE".txt</div><div class="line">	echo "星期$XINQI" &gt;&gt; $LOG_DIR</div><div class="line">	grep "Backup created in directory" /tmp/"$DATE".txt &gt;&gt; $LOG_DIR</div><div class="line">	rm -rf /tmp/"$DATE".txt</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 增量备份</div><div class="line"># 注意,此增量会根据 $LOG_DIR 文件中的最后一次的文件来做增量</div><div class="line">inc()</div><div class="line">&#123;</div><div class="line">	if [[ ! -s $LOG_DIR ]];then</div><div class="line">		full</div><div class="line">		exit 0</div><div class="line">	fi</div><div class="line">	$Innobackupex_Path $MYSQL_OPS --incremental "$BACKUP_INC" --incremental-basedir=$COMPLETE &amp;&gt; /tmp/"$DATE".txt</div><div class="line">	echo "星期$XINQI" &gt;&gt; $LOG_DIR</div><div class="line">	grep "Backup created in directory" /tmp/"$DATE".txt &gt;&gt; $LOG_DIR</div><div class="line">	rm -rf /tmp/"$DATE".txt</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 删除一月前的全备和増备</div><div class="line">del()</div><div class="line">&#123;</div><div class="line">	for old_file in $(find $BACKUP_FULL $BACKUP_INC -mtime +30)</div><div class="line">	do</div><div class="line">		rm -rf "$&#123;old_file&#125;"</div><div class="line">	done</div><div class="line">&#125;</div><div class="line"></div><div class="line">case $1 in</div><div class="line">	full)</div><div class="line">        check</div><div class="line">		del</div><div class="line">        full</div><div class="line">        ;;</div><div class="line">	inc)</div><div class="line">    	check</div><div class="line">	    del</div><div class="line">        inc</div><div class="line">        ;;</div><div class="line">	 *)</div><div class="line">cat &lt;&lt; EOF</div><div class="line">+----------------+</div><div class="line">+ Use:           +</div><div class="line">+ full  全量恢复 +</div><div class="line">+ inc   增量恢复 +</div><div class="line">+----------------+</div><div class="line">EOF</div><div class="line">      	;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;需要一个MySQL的自动备份脚本，于是google了一下，发现不是自己看不懂就是运行有问题。那么迫于无赖，不能偷懒了，只能写一个比较适合自己的脚本。脚本较烂，还望轻喷。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chen-hao.com.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="xtrabackup" scheme="http://chen-hao.com.cn/tags/xtrabackup/"/>
    
  </entry>
  
</feed>
